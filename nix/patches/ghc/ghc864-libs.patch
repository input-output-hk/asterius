diff -ruN -x '*.rej' -x '*.orig' old/libraries/base/Asterius/Prim.hs new/libraries/base/Asterius/Prim.hs
--- old/libraries/base/Asterius/Prim.hs	1970-01-01 12:00:00.000000000 +1200
+++ new/libraries/base/Asterius/Prim.hs	2019-05-13 13:38:14.000000000 +1200
@@ -0,0 +1,12 @@
+{-# LANGUAGE CPP #-}
+{-# LANGUAGE NoImplicitPrelude #-}
+
+module Asterius.Prim where
+
+#if defined(ASTERIUS)
+
+import GHC.Base
+
+foreign import javascript "__asterius_jsffi.stdio.putChar(${1},${2})" js_putChar :: Int -> Char -> IO ()
+
+#endif
diff -ruN -x '*.rej' -x '*.orig' old/libraries/base/Asterius/Types.hs new/libraries/base/Asterius/Types.hs
--- old/libraries/base/Asterius/Types.hs	1970-01-01 12:00:00.000000000 +1200
+++ new/libraries/base/Asterius/Types.hs	2019-05-13 13:38:14.000000000 +1200
@@ -0,0 +1,227 @@
+{-# LANGUAGE MagicHash #-}
+{-# LANGUAGE NoImplicitPrelude #-}
+{-# LANGUAGE UnboxedTuples #-}
+{-# LANGUAGE UnliftedFFITypes #-}
+
+module Asterius.Types
+  ( JSVal(..)
+  , JSArrayBuffer(..)
+  , JSString(..)
+  , JSArray(..)
+  , JSObject(..)
+  , JSFunction(..)
+  , fromJSArrayBuffer
+  , toJSArrayBuffer
+  , fromJSString
+  , toJSString
+  , fromJSArray
+  , toJSArray
+  , indexJSObject
+  , setJSObject
+  , jsonParse
+  , jsonStringify
+  , callJSFunction
+  , makeHaskellCallback
+  , makeHaskellCallback1
+  , makeHaskellCallback2
+  , jsStringDecodeUTF8
+  , jsStringEncodeUTF8
+  , jsStringDecodeLatin1
+  , jsStringEncodeLatin1
+  , jsStringDecodeUTF16LE
+  , jsStringEncodeUTF16LE
+  , jsStringDecodeUTF32LE
+  , jsStringEncodeUTF32LE
+  , js_freezeTmpJSVal
+  ) where
+
+import Asterius.Magic
+import GHC.Magic
+import GHC.Prim
+import GHC.Stable
+import GHC.Tuple
+import GHC.Types
+
+newtype JSVal =
+  JSVal (StablePtr ())
+
+newtype JSArrayBuffer =
+  JSArrayBuffer JSVal
+
+newtype JSString =
+  JSString JSVal
+
+newtype JSArray =
+  JSArray JSVal
+
+newtype JSObject =
+  JSObject JSVal
+
+newtype JSFunction =
+  JSFunction JSVal
+
+{-# INLINE fromJSArrayBuffer #-}
+fromJSArrayBuffer :: JSArrayBuffer -> ByteArray#
+fromJSArrayBuffer buf = accursedUnutterableAddrToAny (c_fromJSArrayBuffer buf)
+
+{-# INLINE toJSArrayBuffer #-}
+toJSArrayBuffer :: Addr# -> Int -> JSArrayBuffer
+toJSArrayBuffer = c_toJSArrayBuffer
+
+{-# INLINE indexJSObject #-}
+indexJSObject :: JSObject -> [Char] -> IO JSVal
+indexJSObject obj k = js_object_index obj (toJSString k)
+
+{-# INLINE setJSObject #-}
+setJSObject :: JSObject -> [Char] -> JSVal -> IO ()
+setJSObject obj k = js_object_set obj (toJSString k)
+
+{-# INLINE jsonParse #-}
+jsonParse :: [Char] -> JSVal
+jsonParse s = js_jsonParse (toJSString s)
+
+{-# INLINE jsonStringify #-}
+jsonStringify :: JSVal -> [Char]
+jsonStringify v = fromJSString (js_jsonStringify v)
+
+{-# INLINE callJSFunction #-}
+callJSFunction :: JSFunction -> [JSVal] -> IO JSVal
+callJSFunction f args = js_apply f (toJSArray args)
+
+{-# INLINE makeHaskellCallback #-}
+makeHaskellCallback :: IO () -> IO JSFunction
+makeHaskellCallback f =
+  IO
+    (\s0 ->
+       case makeStablePtr# f s0 of
+         (# s1, sp #) -> unIO (js_mk_hs_callback sp) s1)
+
+{-# INLINE makeHaskellCallback1 #-}
+makeHaskellCallback1 :: (JSVal -> IO ()) -> IO JSFunction
+makeHaskellCallback1 f =
+  IO
+    (\s0 ->
+       case makeStablePtr# f s0 of
+         (# s1, sp #) -> unIO (js_mk_hs_callback1 sp) s1)
+
+{-# INLINE makeHaskellCallback2 #-}
+makeHaskellCallback2 :: (JSVal -> JSVal -> IO ()) -> IO JSFunction
+makeHaskellCallback2 f =
+  IO
+    (\s0 ->
+       case makeStablePtr# f s0 of
+         (# s1, sp #) -> unIO (js_mk_hs_callback2 sp) s1)
+
+{-# INLINE fromJSString #-}
+fromJSString :: JSString -> [Char]
+fromJSString s = accursedUnutterableAddrToAny (c_fromJSString s)
+
+{-# INLINE toJSString #-}
+toJSString :: [Char] -> JSString
+toJSString s =
+  runRW#
+    (\s0 ->
+       case unIO js_newString s0 of
+         (# s1, i #) ->
+           let w [] sx = (# sx, () #)
+               w (c:cs) sx =
+                 case unIO (js_appendString i c) sx of
+                   (# sy, _ #) -> w cs sy
+            in case w s s1 of
+                 (# s2, _ #) ->
+                   case unIO (js_freezeTmpJSVal i) s2 of
+                     (# _, r #) -> JSString r)
+
+{-# INLINE fromJSArray #-}
+fromJSArray :: JSArray -> [JSVal]
+fromJSArray arr = accursedUnutterableAddrToAny (c_fromJSArray arr)
+
+{-# INLINE toJSArray #-}
+toJSArray :: [JSVal] -> JSArray
+toJSArray arr =
+  runRW#
+    (\s0 ->
+       case unIO js_newArray s0 of
+         (# s1, i #) ->
+           let w [] sx = (# sx, () #)
+               w (v:vs) sx =
+                 case unIO (js_appendArray i v) sx of
+                   (# sy, _ #) -> w vs sy
+            in case w arr s1 of
+                 (# s2, _ #) ->
+                   case unIO (js_freezeTmpJSVal i) s2 of
+                     (# _, r #) -> JSArray r)
+
+foreign import ccall unsafe "__asterius_fromJSArrayBuffer" c_fromJSArrayBuffer
+  :: JSArrayBuffer -> Addr#
+
+foreign import ccall unsafe "__asterius_toJSArrayBuffer" c_toJSArrayBuffer
+  :: Addr# -> Int -> JSArrayBuffer
+
+foreign import ccall unsafe "__asterius_fromJSString" c_fromJSString
+  :: JSString -> Addr#
+
+foreign import ccall unsafe "__asterius_fromJSArray" c_fromJSArray
+  :: JSArray -> Addr#
+
+foreign import javascript "__asterius_jsffi.newTmpJSVal('')" js_newString
+  :: IO Int
+
+foreign import javascript "__asterius_jsffi.mutTmpJSVal(${1}, s => s + String.fromCodePoint(${2}))" js_appendString
+  :: Int -> Char -> IO ()
+
+foreign import javascript "__asterius_jsffi.newTmpJSVal([])" js_newArray
+  :: IO Int
+
+foreign import javascript "__asterius_jsffi.mutTmpJSVal(${1}, arr => (arr.push(${2}), arr))" js_appendArray
+  :: Int -> JSVal -> IO ()
+
+foreign import javascript "__asterius_jsffi.freezeTmpJSVal(${1})" js_freezeTmpJSVal
+  :: Int -> IO JSVal
+
+foreign import javascript "__asterius_jsffi.decodeUTF8(${1})" jsStringDecodeUTF8
+  :: JSArrayBuffer -> JSString
+
+foreign import javascript "__asterius_jsffi.encodeUTF8(${1})" jsStringEncodeUTF8
+  :: JSString -> JSArrayBuffer
+
+foreign import javascript "__asterius_jsffi.decodeLatin1(${1})" jsStringDecodeLatin1
+  :: JSArrayBuffer -> JSString
+
+foreign import javascript "__asterius_jsffi.encodeLatin1(${1})" jsStringEncodeLatin1
+  :: JSString -> JSArrayBuffer
+
+foreign import javascript "__asterius_jsffi.decodeUTF16LE(${1})" jsStringDecodeUTF16LE
+  :: JSArrayBuffer -> JSString
+
+foreign import javascript "__asterius_jsffi.encodeUTF16LE(${1})" jsStringEncodeUTF16LE
+  :: JSString -> JSArrayBuffer
+
+foreign import javascript "__asterius_jsffi.decodeUTF32LE(${1})" jsStringDecodeUTF32LE
+  :: JSArrayBuffer -> JSString
+
+foreign import javascript "__asterius_jsffi.encodeUTF32LE(${1})" jsStringEncodeUTF32LE
+  :: JSString -> JSArrayBuffer
+
+foreign import javascript "${1}[${2}]" js_object_index
+  :: JSObject -> JSString -> IO JSVal
+
+foreign import javascript "${1}[${2}]=${3}" js_object_set
+  :: JSObject -> JSString -> JSVal -> IO ()
+
+foreign import javascript "${1}.apply({},${2})" js_apply
+  :: JSFunction -> JSArray -> IO JSVal
+
+foreign import javascript "__asterius_jsffi.makeHaskellCallback(${1})" js_mk_hs_callback
+  :: StablePtr# (IO ()) -> IO JSFunction
+
+foreign import javascript "__asterius_jsffi.makeHaskellCallback1(${1})" js_mk_hs_callback1
+  :: StablePtr# (JSVal -> IO ()) -> IO JSFunction
+
+foreign import javascript "__asterius_jsffi.makeHaskellCallback2(${1})" js_mk_hs_callback2
+  :: StablePtr# (JSVal -> JSVal -> IO ()) -> IO JSFunction
+
+foreign import javascript "JSON.parse(${1})" js_jsonParse :: JSString -> JSVal
+
+foreign import javascript "JSON.stringify(${1})" js_jsonStringify
+  :: JSVal -> JSString
diff -ruN -x '*.rej' -x '*.orig' old/libraries/base/Data/Bits.hs new/libraries/base/Data/Bits.hs
--- old/libraries/base/Data/Bits.hs	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/base/Data/Bits.hs	2019-05-13 13:38:14.000000000 +1200
@@ -555,8 +555,8 @@
    zeroBits      = wordToNaturalBase 0##
    clearBit x i  = x `xor` (bit i .&. x)
 
-   bit (I# i#) = bitNatural i#
-   popCount x  = popCountNatural x
+   bit (I# i#) = errorWithoutStackTrace "bitNatural"
+   popCount x  = errorWithoutStackTrace "popCountNatural"
 
    rotate x i = shift x i   -- since an Natural never wraps around
 
diff -ruN -x '*.rej' -x '*.orig' old/libraries/base/GHC/IO/Handle/FD.hs new/libraries/base/GHC/IO/Handle/FD.hs
--- old/libraries/base/GHC/IO/Handle/FD.hs	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/base/GHC/IO/Handle/FD.hs	2019-05-13 13:38:14.000000000 +1200
@@ -6,7 +6,6 @@
 -- Module      :  GHC.IO.Handle.FD
 -- Copyright   :  (c) The University of Glasgow, 1994-2008
 -- License     :  see libraries/base/LICENSE
--- 
 -- Maintainer  :  libraries@haskell.org
 -- Stability   :  internal
 -- Portability :  non-portable
@@ -15,7 +14,7 @@
 --
 -----------------------------------------------------------------------------
 
-module GHC.IO.Handle.FD ( 
+module GHC.IO.Handle.FD (
   stdin, stdout, stderr,
   openFile, openBinaryFile, openFileBlocking,
   mkHandleFromFD, fdToHandle, fdToHandle', handleToFd
@@ -37,6 +36,10 @@
 import qualified GHC.IO.FD as FD
 import qualified System.Posix.Internals as Posix
 
+#if defined(ASTERIUS)
+import GHC.Real (fromIntegral)
+#endif
+
 -- ---------------------------------------------------------------------------
 -- Standard Handles
 
@@ -48,6 +51,9 @@
 -- | A handle managing input from the Haskell program's standard input channel.
 stdin :: Handle
 {-# NOINLINE stdin #-}
+#if defined(ASTERIUS)
+stdin = Handle 0
+#else
 stdin = unsafePerformIO $ do
    -- ToDo: acquire lock
    setBinaryMode FD.stdin
@@ -55,10 +61,14 @@
    mkHandle FD.stdin "<stdin>" ReadHandle True (Just enc)
                 nativeNewlineMode{-translate newlines-}
                 (Just stdHandleFinalizer) Nothing
+#endif
 
 -- | A handle managing output to the Haskell program's standard output channel.
 stdout :: Handle
 {-# NOINLINE stdout #-}
+#if defined(ASTERIUS)
+stdout = Handle 1
+#else
 stdout = unsafePerformIO $ do
    -- ToDo: acquire lock
    setBinaryMode FD.stdout
@@ -66,27 +76,34 @@
    mkHandle FD.stdout "<stdout>" WriteHandle True (Just enc)
                 nativeNewlineMode{-translate newlines-}
                 (Just stdHandleFinalizer) Nothing
+#endif
 
 -- | A handle managing output to the Haskell program's standard error channel.
 stderr :: Handle
 {-# NOINLINE stderr #-}
+#if defined(ASTERIUS)
+stderr = Handle 2
+#else
 stderr = unsafePerformIO $ do
     -- ToDo: acquire lock
    setBinaryMode FD.stderr
    enc <- getLocaleEncoding
-   mkHandle FD.stderr "<stderr>" WriteHandle False{-stderr is unbuffered-} 
+   mkHandle FD.stderr "<stderr>" WriteHandle False{-stderr is unbuffered-}
                 (Just enc)
                 nativeNewlineMode{-translate newlines-}
                 (Just stdHandleFinalizer) Nothing
+#endif
 
+#if !defined(ASTERIUS)
 stdHandleFinalizer :: FilePath -> MVar Handle__ -> IO ()
 stdHandleFinalizer fp m = do
   h_ <- takeMVar m
   flushWriteBuffer h_
-  case haType h_ of 
+  case haType h_ of
       ClosedHandle -> return ()
       _other       -> closeTextCodecs h_
   putMVar m (ioe_finalizedHandle fp)
+#endif
 
 -- We have to put the FDs into binary mode on Windows to avoid the newline
 -- translation that the CRT IO library does.
@@ -139,7 +156,7 @@
 -- Note: if you will be working with files containing binary data, you'll want to
 -- be using 'openBinaryFile'.
 openFile :: FilePath -> IOMode -> IO Handle
-openFile fp im = 
+openFile fp im =
   catchException
     (openFile' fp im dEFAULT_OPEN_IN_BINARY_MODE True)
     (\e -> ioError (addFilePathToIOError "openFile" fp e))
@@ -201,12 +218,14 @@
    -> Bool      --  *set* non-blocking mode on the FD
    -> Maybe TextEncoding
    -> IO Handle
-
+#if defined(ASTERIUS)
+mkHandleFromFD fd _ _ _ _ _ = pure (Handle (fromIntegral (FD.fdFD fd)))
+#else
 mkHandleFromFD fd0 fd_type filepath iomode set_non_blocking mb_codec
   = do
 #if !defined(mingw32_HOST_OS)
     -- turn on non-blocking mode
-    fd <- if set_non_blocking 
+    fd <- if set_non_blocking
              then FD.setNonBlockingMode fd0 True
              else return fd0
 #else
@@ -218,19 +237,20 @@
            | otherwise       = noNewlineTranslation
 
     case fd_type of
-        Directory -> 
+        Directory ->
            ioException (IOError Nothing InappropriateType "openFile"
                            "is a directory" Nothing Nothing)
 
         Stream
            -- only *Streams* can be DuplexHandles.  Other read/write
            -- Handles must share a buffer.
-           | ReadWriteMode <- iomode -> 
+           | ReadWriteMode <- iomode ->
                 mkDuplexHandle fd filepath mb_codec nl
-                   
 
-        _other -> 
+
+        _other ->
            mkFileHandle fd filepath iomode mb_codec nl
+#endif
 
 -- | Old API kept to avoid breaking clients
 fdToHandle' :: CInt
@@ -264,7 +284,7 @@
 fdToHandle fdint = do
    iomode <- Posix.fdGetMode fdint
    (fd,fd_type) <- FD.mkFD fdint iomode Nothing
-            False{-is_socket-} 
+            False{-is_socket-}
               -- NB. the is_socket flag is False, meaning that:
               --  on Windows we're guessing this is not a socket (XXX)
             False{-is_nonblock-}
@@ -272,12 +292,22 @@
               -- not put into non-blocking mode, because that would affect
               -- other users of the file descriptor
    let fd_str = "<file descriptor: " ++ show fd ++ ">"
-   mkHandleFromFD fd fd_type fd_str iomode False{-non-block-} 
+   mkHandleFromFD fd fd_type fd_str iomode False{-non-block-}
                   Nothing -- bin mode
 
 -- | Turn an existing Handle into a file descriptor. This function throws an
 -- IOError if the Handle does not reference a file descriptor.
 handleToFd :: Handle -> IO FD.FD
+#if defined(ASTERIUS)
+handleToFd (Handle h) = pure FD.FD {
+  FD.fdFD = fromIntegral h,
+#if defined(mingw32_HOST_OS)
+  FD.fdIsSocket_ = 0
+#else
+  FD.fdIsNonBlocking = 0
+#endif
+}
+#else
 handleToFd h = case h of
   FileHandle _ mv -> do
     Handle__{haDevice = dev} <- readMVar mv
@@ -288,7 +318,7 @@
   where
     throwErr msg = ioException $ IOError (Just h)
       InappropriateType "handleToFd" msg Nothing Nothing
-
+#endif
 
 -- ---------------------------------------------------------------------------
 -- Are files opened by default in text or binary mode, if the user doesn't
diff -ruN -x '*.rej' -x '*.orig' old/libraries/base/GHC/IO/Handle/Internals.hs new/libraries/base/GHC/IO/Handle/Internals.hs
--- old/libraries/base/GHC/IO/Handle/Internals.hs	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/base/GHC/IO/Handle/Internals.hs	2019-05-13 13:38:14.000000000 +1200
@@ -1,3 +1,4 @@
+{-# LANGUAGE CPP #-}
 {-# LANGUAGE Trustworthy #-}
 {-# LANGUAGE NoImplicitPrelude
            , RecordWildCards
@@ -26,14 +27,14 @@
 -----------------------------------------------------------------------------
 
 module GHC.IO.Handle.Internals (
+#if !defined(ASTERIUS)
   withHandle, withHandle', withHandle_,
   withHandle__', withHandle_', withAllHandles__,
   wantWritableHandle, wantReadableHandle, wantReadableHandle_,
   wantSeekableHandle,
 
   mkHandle, mkFileHandle, mkDuplexHandle,
-  openTextEncoding, closeTextCodecs, initBufferState,
-  dEFAULT_CHAR_BUFFER_SIZE,
+  closeTextCodecs,
 
   flushBuffer, flushWriteBuffer, flushCharReadBuffer,
   flushCharBuffer, flushByteReadBuffer, flushByteWriteBuffer,
@@ -41,14 +42,20 @@
   readTextDevice, writeCharBuffer, readTextDeviceNonBlocking,
   decodeByteBuf,
 
-  augmentIOError,
-  ioe_closedHandle, ioe_semiclosedHandle,
-  ioe_EOF, ioe_notReadable, ioe_notWritable,
-  ioe_finalizedHandle, ioe_bufsiz,
+  ioe_finalizedHandle,
 
   hClose_help, hLookAhead_,
 
   HandleFinalizer, handleFinalizer,
+#endif
+
+  openTextEncoding, initBufferState,
+  dEFAULT_CHAR_BUFFER_SIZE,
+
+  augmentIOError,
+  ioe_closedHandle, ioe_semiclosedHandle,
+  ioe_EOF, ioe_notReadable, ioe_notWritable,
+  ioe_bufsiz,
 
   debugIO,
  ) where
@@ -86,6 +93,8 @@
 -- ---------------------------------------------------------------------------
 -- Creating a new handle
 
+#if !defined(ASTERIUS)
+
 type HandleFinalizer = FilePath -> MVar Handle__ -> IO ()
 
 newFileHandle :: FilePath -> Maybe HandleFinalizer -> Handle__ -> IO Handle
@@ -96,6 +105,8 @@
     Nothing        -> return ()
   return (FileHandle filepath m)
 
+#endif
+
 -- ---------------------------------------------------------------------------
 -- Working with Handles
 
@@ -120,6 +131,8 @@
 original handle is always replaced.
 -}
 
+#if !defined(ASTERIUS)
+
 {-# INLINE withHandle #-}
 withHandle :: String -> Handle -> (Handle__ -> IO (Handle__,a)) -> IO a
 withHandle fun h@(FileHandle _ m)     act = withHandle' fun h m act
@@ -178,6 +191,8 @@
         _otherwise ->
             throwIO e
 
+#endif
+
 -- Note [async]
 --
 -- If an asynchronous exception is raised during an I/O operation,
@@ -213,14 +228,20 @@
 augmentIOError ioe@IOError{ ioe_filename = fp } fun h
   = ioe { ioe_handle = Just h, ioe_location = fun, ioe_filename = filepath }
   where filepath
+#if defined(ASTERIUS)
+                      = Just (show h)
+#else
           | Just _ <- fp = fp
           | otherwise = case h of
                           FileHandle path _     -> Just path
                           DuplexHandle path _ _ -> Just path
+#endif
 
 -- ---------------------------------------------------------------------------
 -- Wrapper for write operations.
 
+#if !defined(ASTERIUS)
+
 wantWritableHandle :: String -> Handle -> (Handle__ -> IO a) -> IO a
 wantWritableHandle fun h@(FileHandle _ m) act
   = wantWritableHandle' fun h m act
@@ -314,6 +335,8 @@
               if b then act handle_
                    else ioe_notSeekable
 
+#endif
+
 -- -----------------------------------------------------------------------------
 -- Handy IOErrors
 
@@ -343,11 +366,15 @@
       "cannot flush the read buffer: underlying device is not seekable"
         Nothing Nothing)
 
+#if !defined(ASTERIUS)
+
 ioe_finalizedHandle :: FilePath -> Handle__
 ioe_finalizedHandle fp = throw
    (IOError Nothing IllegalOperation ""
         "handle is finalized" Nothing (Just fp))
 
+#endif
+
 ioe_bufsiz :: Int -> IO a
 ioe_bufsiz n = ioException
    (IOError Nothing InvalidArgument "hSetBuffering"
@@ -421,6 +448,8 @@
 -- will then report an error.  We'd rather this was not an error and
 -- the program just prints "<<loop>>".
 
+#if !defined(ASTERIUS)
+
 handleFinalizer :: FilePath -> MVar Handle__ -> IO ()
 handleFinalizer fp m = do
   handle_ <- takeMVar m
@@ -428,6 +457,8 @@
   putMVar m handle_'
   return ()
 
+#endif
+
 -- ---------------------------------------------------------------------------
 -- Allocating buffers
 
@@ -462,6 +493,9 @@
 -- | syncs the file with the buffer, including moving the
 -- file pointer backwards in the case of a read buffer.  This can fail
 -- on a non-seekable read Handle.
+
+#if !defined(ASTERIUS)
+
 flushBuffer :: Handle__ -> IO ()
 flushBuffer h_@Handle__{..} = do
   buf <- readIORef haCharBuffer
@@ -609,9 +643,13 @@
 
   writeIORef haByteBuffer bbuf{ bufL=0, bufR=0 }
 
+#endif
+
 -- ----------------------------------------------------------------------------
 -- Making Handles
 
+#if !defined(ASTERIUS)
+
 mkHandle :: (IODevice dev, BufferedIO dev, Typeable dev) => dev
             -> FilePath
             -> HandleType
@@ -691,6 +729,8 @@
 
   return (DuplexHandle filepath read_m write_m)
 
+#endif
+
 ioModeToHandleType :: IOMode -> HandleType
 ioModeToHandleType ReadMode      = ReadHandle
 ioModeToHandleType WriteMode     = WriteHandle
@@ -721,11 +761,15 @@
                      return Nothing
     cont mb_encoder mb_decoder
 
+#if !defined(ASTERIUS)
+
 closeTextCodecs :: Handle__ -> IO ()
 closeTextCodecs Handle__{..} = do
   case haDecoder of Nothing -> return (); Just d -> Encoding.close d
   case haEncoder of Nothing -> return (); Just d -> Encoding.close d
 
+#endif
+
 -- ---------------------------------------------------------------------------
 -- closing Handles
 
@@ -735,6 +779,9 @@
 -- careful with DuplexHandles though: we have to leave the closing to
 -- the finalizer in that case, because the write side may still be in
 -- use.
+
+#if !defined(ASTERIUS)
+
 hClose_help :: Handle__ -> IO (Handle__, Maybe SomeException)
 hClose_help handle_ =
   case haType handle_ of
@@ -746,10 +793,13 @@
               (h_, mb_exc2) <- hClose_handle_ handle_
               return (h_, if isJust mb_exc1 then mb_exc1 else mb_exc2)
 
+#endif
 
 trymaybe :: IO () -> IO (Maybe SomeException)
 trymaybe io = (do io; return Nothing) `catchException` \e -> return (Just e)
 
+#if !defined(ASTERIUS)
+
 hClose_handle_ :: Handle__ -> IO (Handle__, Maybe SomeException)
 hClose_handle_ h_@Handle__{..} = do
 
@@ -778,6 +828,8 @@
     -- XXX GHC won't let us use record update here, hence wildcards
     return (Handle__{ haType = ClosedHandle, .. }, maybe_exception)
 
+#endif
+
 {-# NOINLINE noCharBuffer #-}
 noCharBuffer :: CharBuffer
 noCharBuffer = unsafePerformIO $ newCharBuffer 1 ReadBuffer
@@ -789,6 +841,8 @@
 -- ---------------------------------------------------------------------------
 -- Looking ahead
 
+#if !defined(ASTERIUS)
+
 hLookAhead_ :: Handle__ -> IO Char
 hLookAhead_ handle_@Handle__{..} = do
     buf <- readIORef haCharBuffer
@@ -801,6 +855,8 @@
 
     peekCharBuf (bufRaw buf) (bufL buf)
 
+#endif
+
 -- ---------------------------------------------------------------------------
 -- debugging
 
@@ -828,6 +884,9 @@
 --
 -- Users of this function expect that the buffer returned contains
 -- at least 1 more character than the input buffer.
+
+#if !defined(ASTERIUS)
+
 readTextDevice :: Handle__ -> CharBuffer -> IO CharBuffer
 readTextDevice h_@Handle__{..} cbuf = do
   --
@@ -947,3 +1006,4 @@
   writeIORef haByteBuffer bbuf2
   return cbuf'
 
+#endif
diff -ruN -x '*.rej' -x '*.orig' old/libraries/base/GHC/IO/Handle/Text.hs new/libraries/base/GHC/IO/Handle/Text.hs
--- old/libraries/base/GHC/IO/Handle/Text.hs	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/base/GHC/IO/Handle/Text.hs	2019-05-21 13:33:44.000000000 +1200
@@ -26,7 +26,9 @@
 
 module GHC.IO.Handle.Text (
         hWaitForInput, hGetChar, hGetLine, hGetContents, hPutChar, hPutStr,
+#if !defined(ASTERIUS)
         commitBuffer',       -- hack, see below
+#endif
         hGetBuf, hGetBufSome, hGetBufNonBlocking, hPutBuf, hPutBufNonBlocking,
         memcpy, hPutStrLn,
     ) where
@@ -57,6 +59,10 @@
 import GHC.Show
 import GHC.List
 
+#if defined(ASTERIUS)
+import Asterius.Prim
+#endif
+
 -- ---------------------------------------------------------------------------
 -- Simple input operations
 
@@ -89,6 +95,9 @@
 --
 
 hWaitForInput :: Handle -> Int -> IO Bool
+#if defined(ASTERIUS)
+hWaitForInput = undefined
+#else
 hWaitForInput h msecs = do
   wantReadableHandle_ "hWaitForInput" h $ \ handle_@Handle__{..} -> do
   cbuf <- readIORef haCharBuffer
@@ -117,6 +126,7 @@
                 -- and re-running IODevice.ready if we don't have any full
                 -- characters; but we don't know how long we've waited
                 -- so far.
+#endif
 
 -- ---------------------------------------------------------------------------
 -- hGetChar
@@ -129,6 +139,9 @@
 --  * 'isEOFError' if the end of file has been reached.
 
 hGetChar :: Handle -> IO Char
+#if defined(ASTERIUS)
+hGetChar = undefined
+#else
 hGetChar handle =
   wantReadableHandle_ "hGetChar" handle $ \handle_@Handle__{..} -> do
 
@@ -169,6 +182,7 @@
      else do
             writeIORef haCharBuffer buf2
             return c1
+#endif
 
 -- ---------------------------------------------------------------------------
 -- hGetLine
@@ -186,9 +200,15 @@
 -- line is returned.
 
 hGetLine :: Handle -> IO String
+#if defined(ASTERIUS)
+hGetLine = undefined
+#else
 hGetLine h =
   wantReadableHandle_ "hGetLine" h $ \ handle_ -> do
      hGetLineBuffered handle_
+#endif
+
+#if !defined(ASTERIUS)
 
 hGetLineBuffered :: Handle__ -> IO String
 hGetLineBuffered handle_@Handle__{..} = do
@@ -254,6 +274,8 @@
                   then return Nothing
                   else ioError e)
 
+#endif
+
 -- See GHC.IO.Buffer
 #define CHARBUF_UTF32
 -- #define CHARBUF_UTF16
@@ -375,15 +397,21 @@
 --  * 'isEOFError' if the end of file has been reached.
 
 hGetContents :: Handle -> IO String
+#if defined(ASTERIUS)
+hGetContents = undefined
+#else
 hGetContents handle =
    wantReadableHandle "hGetContents" handle $ \handle_ -> do
       xs <- lazyRead handle
       return (handle_{ haType=SemiClosedHandle}, xs )
+#endif
 
 -- Note that someone may close the semi-closed handle (or change its
 -- buffering), so each time these lazy read functions are pulled on,
 -- they have to check whether the handle has indeed been closed.
 
+#if !defined(ASTERIUS)
+
 lazyRead :: Handle -> IO String
 lazyRead handle =
    unsafeInterleaveIO $
@@ -452,6 +480,7 @@
     -- buffer has some chars in it already: just return it
     _otherwise ->
       return buf
+#endif
 
 -- ---------------------------------------------------------------------------
 -- hPutChar
@@ -467,11 +496,16 @@
 --  * 'isPermissionError' if another system resource limit would be exceeded.
 
 hPutChar :: Handle -> Char -> IO ()
+#if defined(ASTERIUS)
+hPutChar (Handle h) c = js_putChar h c
+#else
 hPutChar handle c = do
     c `seq` return ()
     wantWritableHandle "hPutChar" handle $ \ handle_  -> do
      hPutcBuffered handle_ c
+#endif
 
+#if !defined(ASTERIUS)
 hPutcBuffered :: Handle__ -> Char -> IO ()
 hPutcBuffered handle_@Handle__{..} c = do
   buf <- readIORef haCharBuffer
@@ -497,6 +531,7 @@
        debugIO ("putc: " ++ summaryBuffer buf)
        w'  <- writeCharBuf raw w c
        return buf{ bufR = w' }
+#endif
 
 -- ---------------------------------------------------------------------------
 -- hPutStr
@@ -539,6 +574,12 @@
 
 {-# NOINLINE hPutStr' #-}
 hPutStr' :: Handle -> String -> Bool -> IO ()
+#if defined(ASTERIUS)
+hPutStr' handle str add_nl =
+  do
+    hPutChars handle str
+    when add_nl $ hPutChar handle '\n'
+#else
 hPutStr' handle str add_nl =
   do
     (buffer_mode, nl) <-
@@ -554,11 +595,13 @@
             writeBlocks handle True  add_nl nl buf str
        (BlockBuffering _, buf) -> do
             writeBlocks handle False add_nl nl buf str
+#endif
 
 hPutChars :: Handle -> [Char] -> IO ()
 hPutChars _      [] = return ()
 hPutChars handle (c:cs) = hPutChar handle c >> hPutChars handle cs
 
+#if !defined(ASTERIUS)
 getSpareBuffer :: Handle__ -> IO (BufferMode, CharBuffer)
 getSpareBuffer Handle__{haCharBuffer=ref,
                         haBuffers=spare_ref,
@@ -576,9 +619,10 @@
             BufferListNil -> do
                 new_buf <- newCharBuffer (bufSize buf) WriteBuffer
                 return (mode, new_buf)
-
+#endif
 
 -- NB. performance-critical code: eyeball the Core.
+#if !defined(ASTERIUS)
 writeBlocks :: Handle -> Bool -> Bool -> Newline -> Buffer CharBufElem -> String -> IO ()
 writeBlocks hdl line_buffered add_nl nl
             buf@Buffer{ bufRaw=raw, bufSize=len } s =
@@ -612,6 +656,7 @@
         shoveString n' cs rest
   in
   shoveString 0 s (if add_nl then "\n" else "")
+#endif
 
 -- -----------------------------------------------------------------------------
 -- commitBuffer handle buf sz count flush release
@@ -619,6 +664,7 @@
 -- Write the contents of the buffer 'buf' ('sz' bytes long, containing
 -- 'count' bytes of data) to handle (handle must be block or line buffered).
 
+#if !defined(ASTERIUS)
 commitBuffer
         :: Handle                       -- handle to commit to
         -> RawCharBuffer -> Int         -- address and size (in bytes) of buffer
@@ -671,6 +717,7 @@
                writeIORef haBuffers (BufferListCons raw spare_bufs)
 
       return this_buf
+#endif
 
 -- ---------------------------------------------------------------------------
 -- Reading/writing sequences of bytes.
@@ -717,6 +764,9 @@
   | count == 0 = return 0
   | count <  0 = illegalBufferSize handle "hPutBuf" count
   | otherwise =
+#if defined(ASTERIUS)
+    undefined
+#else
     wantWritableHandle "hPutBuf" handle $
       \ h_@Handle__{..} -> do
           debugIO ("hPutBuf count=" ++ show count)
@@ -730,7 +780,9 @@
              BlockBuffering _      -> do return ()
              _line_or_no_buffering -> do flushWriteBuffer h_
           return r
+#endif
 
+#if !defined(ASTERIUS)
 bufWrite :: Handle__-> Ptr Word8 -> Int -> Bool -> IO Int
 bufWrite h_@Handle__{..} ptr count can_block =
   seq count $ do  -- strictness hack
@@ -788,6 +840,7 @@
 writeChunkNonBlocking h_@Handle__{..} ptr bytes
   | Just fd <- cast haDevice  =  RawIO.writeNonBlocking (fd::FD) ptr bytes
   | otherwise = error "Todo: hPutBuf"
+#endif
 
 -- ---------------------------------------------------------------------------
 -- hGetBuf
@@ -808,6 +861,9 @@
 -- on the 'Handle', and reads bytes directly.
 
 hGetBuf :: Handle -> Ptr a -> Int -> IO Int
+#if defined(ASTERIUS)
+hGetBuf = undefined
+#else
 hGetBuf h ptr count
   | count == 0 = return 0
   | count <  0 = illegalBufferSize h "hGetBuf" count
@@ -819,11 +875,13 @@
          if isEmptyBuffer buf
             then bufReadEmpty    h_ buf (castPtr ptr) 0 count
             else bufReadNonEmpty h_ buf (castPtr ptr) 0 count
+#endif
 
 -- small reads go through the buffer, large reads are satisfied by
 -- taking data first from the buffer and then direct from the file
 -- descriptor.
 
+#if !defined(ASTERIUS)
 bufReadNonEmpty :: Handle__ -> Buffer Word8 -> Ptr Word8 -> Int -> Int -> IO Int
 bufReadNonEmpty h_@Handle__{..}
                 buf@Buffer{ bufRaw=raw, bufR=w, bufL=r, bufSize=sz }
@@ -868,6 +926,7 @@
     if r == 0
         then return (so_far + off)
         else loop fd (off + r) (bytes - r)
+#endif
 
 -- ---------------------------------------------------------------------------
 -- hGetBufSome
@@ -890,6 +949,9 @@
 -- on the 'Handle', and reads bytes directly.
 
 hGetBufSome :: Handle -> Ptr a -> Int -> IO Int
+#if defined(ASTERIUS)
+hGetBufSome = undefined
+#else
 hGetBufSome h ptr count
   | count == 0 = return 0
   | count <  0 = illegalBufferSize h "hGetBufSome" count
@@ -911,9 +973,12 @@
             else
               let count' = min count (bufferElems buf)
               in bufReadNBNonEmpty h_ buf (castPtr ptr) 0 count'
+#endif
 
+#if !defined(ASTERIUS)
 haFD :: Handle__ -> Maybe FD
 haFD h_@Handle__{..} = cast haDevice
+#endif
 
 -- | 'hGetBufNonBlocking' @hdl buf count@ reads data from the handle @hdl@
 -- into the buffer @buf@ until either EOF is reached, or
@@ -935,6 +1000,9 @@
 -- behaves identically to 'hGetBuf'.
 
 hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
+#if defined(ASTERIUS)
+hGetBufNonBlocking = undefined
+#else
 hGetBufNonBlocking h ptr count
   | count == 0 = return 0
   | count <  0 = illegalBufferSize h "hGetBufNonBlocking" count
@@ -946,7 +1014,9 @@
          if isEmptyBuffer buf
             then bufReadNBEmpty    h_ buf (castPtr ptr) 0 count
             else bufReadNBNonEmpty h_ buf (castPtr ptr) 0 count
+#endif
 
+#if !defined(ASTERIUS)
 bufReadNBEmpty :: Handle__ -> Buffer Word8 -> Ptr Word8 -> Int -> Int -> IO Int
 bufReadNBEmpty   h_@Handle__{..}
                  buf@Buffer{ bufRaw=raw, bufR=w, bufL=r, bufSize=sz }
@@ -996,6 +1066,7 @@
         if remaining == 0
            then return so_far'
            else bufReadNBEmpty h_ buf' ptr' so_far' remaining
+#endif
 
 -- ---------------------------------------------------------------------------
 -- memcpy wrappers
diff -ruN -x '*.rej' -x '*.orig' old/libraries/base/GHC/IO/Handle/Types.hs new/libraries/base/GHC/IO/Handle/Types.hs
--- old/libraries/base/GHC/IO/Handle/Types.hs	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/base/GHC/IO/Handle/Types.hs	2019-05-21 13:41:17.000000000 +1200
@@ -21,8 +21,12 @@
 -----------------------------------------------------------------------------
 
 module GHC.IO.Handle.Types (
-      Handle(..), Handle__(..), showHandle,
+#if !defined(ASTERIUS)
+      Handle__(..),
       checkHandleInvariants,
+#endif
+      Handle(..),
+      showHandle,
       BufferList(..),
       HandleType(..),
       isReadableHandleType, isWritableHandleType, isReadWriteHandleType,
@@ -95,6 +99,12 @@
 -- equal according to '==' only to itself; no attempt
 -- is made to compare the internal state of different handles for equality.
 
+#if defined(ASTERIUS)
+
+newtype Handle = Handle Int
+
+#else
+
 data Handle
   = FileHandle                          -- A normal handle to a file
         FilePath                        -- the file (used for error messages
@@ -108,16 +118,30 @@
         !(MVar Handle__)                -- The read side
         !(MVar Handle__)                -- The write side
 
+#endif
+
 -- NOTES:
 --    * A 'FileHandle' is seekable.  A 'DuplexHandle' may or may not be
 --      seekable.
 
 -- | @since 4.1.0.0
+
+#if defined(ASTERIUS)
+
+instance Eq Handle where
+ Handle h1 == Handle h2 = h1 == h2
+
+#else
+
 instance Eq Handle where
  (FileHandle _ h1)     == (FileHandle _ h2)     = h1 == h2
  (DuplexHandle _ h1 _) == (DuplexHandle _ h2 _) = h1 == h2
  _ == _ = False
 
+#endif
+
+#if !defined(ASTERIUS)
+
 data Handle__
   = forall dev enc_state dec_state . (IODevice dev, BufferedIO dev, Typeable dev) =>
     Handle__ {
@@ -137,6 +161,8 @@
                                              -- duplex handle.
     }
 
+#endif
+
 -- we keep a few spare buffers around in a handle to avoid allocating
 -- a new one for each hPutStr.  These buffers are *guaranteed* to be the
 -- same size as the main buffer.
@@ -178,6 +204,8 @@
 --   * In a read Handle, the byte buffer is always empty (we decode when reading)
 --   * In a wriite Handle, the Char buffer is always empty (we encode when writing)
 --
+#if !defined(ASTERIUS)
+
 checkHandleInvariants :: Handle__ -> IO ()
 #if defined(DEBUG)
 checkHandleInvariants h_ = do
@@ -196,6 +224,8 @@
 checkHandleInvariants _ = return ()
 #endif
 
+#endif
+
 -- ---------------------------------------------------------------------------
 -- Buffering modes
 
@@ -432,10 +462,19 @@
       ReadWriteHandle   -> showString "read-writable"
 
 -- | @since 4.1.0.0
+#if defined(ASTERIUS)
+
+instance Show Handle where
+  showsPrec _ (Handle h) = showString "{handle: " . shows h . showString "}"
+
+#else
+
 instance Show Handle where
   showsPrec _ (FileHandle   file _)   = showHandle file
   showsPrec _ (DuplexHandle file _ _) = showHandle file
 
+#endif
+
 showHandle :: FilePath -> String -> String
 showHandle file = showString "{handle: " . showString file . showString "}"
 
diff -ruN -x '*.rej' -x '*.orig' old/libraries/base/GHC/IO/Handle.hs new/libraries/base/GHC/IO/Handle.hs
--- old/libraries/base/GHC/IO/Handle.hs	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/base/GHC/IO/Handle.hs	2019-05-21 13:52:59.000000000 +1200
@@ -21,16 +21,19 @@
 -----------------------------------------------------------------------------
 
 module GHC.IO.Handle (
+#if !defined(ASTERIUS)
+   mkFileHandle, mkDuplexHandle,
+
+   hClose_help,
+#endif
    Handle,
    BufferMode(..),
 
-   mkFileHandle, mkDuplexHandle,
-
    hFileSize, hSetFileSize, hIsEOF, isEOF, hLookAhead,
    hSetBuffering, hSetBinaryMode, hSetEncoding, hGetEncoding,
    hFlush, hFlushAll, hDuplicate, hDuplicateTo,
 
-   hClose, hClose_help,
+   hClose,
 
    LockMode(..), hLock, hTryLock,
 
@@ -86,13 +89,18 @@
 -- closed.
 
 hClose :: Handle -> IO ()
+#if defined(ASTERIUS)
+hClose = undefined
+#else
 hClose h@(FileHandle _ m)     = do
   mb_exc <- hClose' h m
   hClose_maybethrow mb_exc h
 hClose h@(DuplexHandle _ r w) = do
   excs <- mapM (hClose' h) [r,w]
   hClose_maybethrow (listToMaybe (catMaybes excs)) h
+#endif
 
+#if !defined(ASTERIUS)
 hClose_maybethrow :: Maybe SomeException -> Handle -> IO ()
 hClose_maybethrow Nothing  h = return ()
 hClose_maybethrow (Just e) h = hClose_rethrow e h
@@ -105,6 +113,7 @@
 
 hClose' :: Handle -> MVar Handle__ -> IO (Maybe SomeException)
 hClose' h m = withHandle' "hClose" h m $ hClose_help
+#endif
 
 -----------------------------------------------------------------------------
 -- Detecting and changing the size of a file
@@ -113,6 +122,9 @@
 -- 'hFileSize' @hdl@ returns the size of that file in 8-bit bytes.
 
 hFileSize :: Handle -> IO Integer
+#if defined(ASTERIUS)
+hFileSize = undefined
+#else
 hFileSize handle =
     withHandle_ "hFileSize" handle $ \ handle_@Handle__{haDevice=dev} -> do
     case haType handle_ of
@@ -124,11 +136,14 @@
                  then return r
                  else ioException (IOError Nothing InappropriateType "hFileSize"
                                    "not a regular file" Nothing Nothing)
-
+#endif
 
 -- | 'hSetFileSize' @hdl@ @size@ truncates the physical file with handle @hdl@ to @size@ bytes.
 
 hSetFileSize :: Handle -> Integer -> IO ()
+#if defined(ASTERIUS)
+hSetFileSize = undefined
+#else
 hSetFileSize handle size =
     withHandle_ "hSetFileSize" handle $ \ handle_@Handle__{haDevice=dev} -> do
     case haType handle_ of
@@ -137,6 +152,7 @@
       _ -> do flushWriteBuffer handle_
               IODevice.setSize dev size
               return ()
+#endif
 
 -- ---------------------------------------------------------------------------
 -- Detecting the End of Input
@@ -150,6 +166,9 @@
 -- the stream to determine whether there is any more data to be read.
 
 hIsEOF :: Handle -> IO Bool
+#if defined(ASTERIUS)
+hIsEOF = undefined
+#else
 hIsEOF handle = wantReadableHandle_ "hIsEOF" handle $ \Handle__{..} -> do
 
   cbuf <- readIORef haCharBuffer
@@ -164,6 +183,7 @@
      then return True
      else do writeIORef haByteBuffer bbuf'
              return False
+#endif
 
 -- ---------------------------------------------------------------------------
 -- isEOF
@@ -186,8 +206,12 @@
 --  * 'isEOFError' if the end of file has been reached.
 
 hLookAhead :: Handle -> IO Char
+#if defined(ASTERIUS)
+hLookAhead = undefined
+#else
 hLookAhead handle =
   wantReadableHandle_ "hLookAhead"  handle hLookAhead_
+#endif
 
 -- ---------------------------------------------------------------------------
 -- Buffering Operations
@@ -213,6 +237,9 @@
 --    to be changed.
 
 hSetBuffering :: Handle -> BufferMode -> IO ()
+#if defined(ASTERIUS)
+hSetBuffering = undefined
+#else
 hSetBuffering handle mode =
   withAllHandles__ "hSetBuffering" handle $ \ handle_@Handle__{..} -> do
   case haType of
@@ -245,6 +272,7 @@
           writeIORef haBuffers BufferListNil
 
           return Handle__{ haBufferMode = mode,.. }
+#endif
 
 -- -----------------------------------------------------------------------------
 -- hSetEncoding
@@ -262,6 +290,9 @@
 -- the encoding.
 --
 hSetEncoding :: Handle -> TextEncoding -> IO ()
+#if defined(ASTERIUS)
+hSetEncoding = undefined
+#else
 hSetEncoding hdl encoding = do
   withAllHandles__ "hSetEncoding" hdl $ \h_@Handle__{..} -> do
     flushCharBuffer h_
@@ -273,6 +304,7 @@
                       haDecoder = mb_decoder,
                       haEncoder = mb_encoder,
                       haCodec   = Just encoding, .. })
+#endif
 
 -- | Return the current 'TextEncoding' for the specified 'Handle', or
 -- 'Nothing' if the 'Handle' is in binary mode.
@@ -284,8 +316,12 @@
 -- extra byte-order-mark being written to the file.
 --
 hGetEncoding :: Handle -> IO (Maybe TextEncoding)
+#if defined(ASTERIUS)
+hGetEncoding = undefined
+#else
 hGetEncoding hdl =
   withHandle_ "hGetEncoding" hdl $ \h_@Handle__{..} -> return haCodec
+#endif
 
 -- -----------------------------------------------------------------------------
 -- hFlush
@@ -302,7 +338,11 @@
 --    or retained under these circumstances.
 
 hFlush :: Handle -> IO ()
+#if defined(ASTERIUS)
+hFlush = undefined
+#else
 hFlush handle = wantWritableHandle "hFlush" handle flushWriteBuffer
+#endif
 
 -- | The action 'hFlushAll' @hdl@ flushes all buffered data in @hdl@,
 -- including any buffered read data.  Buffered read data is flushed
@@ -322,7 +362,11 @@
 --    seekable.
 
 hFlushAll :: Handle -> IO ()
+#if defined(ASTERIUS)
+hFlushAll = undefined
+#else
 hFlushAll handle = withHandle_ "hFlushAll" handle flushBuffer
+#endif
 
 -- -----------------------------------------------------------------------------
 -- Repositioning Handles
@@ -397,6 +441,9 @@
 --  * 'isPermissionError' if a system resource limit would be exceeded.
 
 hSeek :: Handle -> SeekMode -> Integer -> IO ()
+#if defined(ASTERIUS)
+hSeek = undefined
+#else
 hSeek handle mode offset =
     wantSeekableHandle "hSeek" handle $ \ handle_@Handle__{..} -> do
     debugIO ("hSeek " ++ show (mode,offset))
@@ -416,7 +463,7 @@
     flushCharReadBuffer handle_
     flushByteReadBuffer handle_
     IODevice.seek haDevice mode offset
-
+#endif
 
 -- | Computation 'hTell' @hdl@ returns the current position of the
 -- handle @hdl@, as the number of bytes from the beginning of
@@ -428,6 +475,9 @@
 --  * 'isIllegalOperationError' if the Handle is not seekable.
 --
 hTell :: Handle -> IO Integer
+#if defined(ASTERIUS)
+hTell = undefined
+#else
 hTell handle =
     wantSeekableHandle "hGetPosn" handle $ \ handle_@Handle__{..} -> do
 
@@ -449,6 +499,7 @@
             "   bbuf: " ++ summaryBuffer bbuf)
 
       return real_posn
+#endif
 
 -- -----------------------------------------------------------------------------
 -- Handle Properties
@@ -458,19 +509,27 @@
 -- the specified property, and `False' otherwise.
 
 hIsOpen :: Handle -> IO Bool
+#if defined(ASTERIUS)
+hIsOpen = undefined
+#else
 hIsOpen handle =
     withHandle_ "hIsOpen" handle $ \ handle_ -> do
     case haType handle_ of
       ClosedHandle         -> return False
       SemiClosedHandle     -> return False
       _                    -> return True
+#endif
 
 hIsClosed :: Handle -> IO Bool
+#if defined(ASTERIUS)
+hIsClosed = undefined
+#else
 hIsClosed handle =
     withHandle_ "hIsClosed" handle $ \ handle_ -> do
     case haType handle_ of
       ClosedHandle         -> return True
       _                    -> return False
+#endif
 
 {- not defined, nor exported, but mentioned
    here for documentation purposes:
@@ -483,6 +542,9 @@
 -}
 
 hIsReadable :: Handle -> IO Bool
+#if defined(ASTERIUS)
+hIsReadable = undefined
+#else
 hIsReadable (DuplexHandle _ _ _) = return True
 hIsReadable handle =
     withHandle_ "hIsReadable" handle $ \ handle_ -> do
@@ -490,8 +552,12 @@
       ClosedHandle         -> ioe_closedHandle
       SemiClosedHandle     -> ioe_semiclosedHandle
       htype                -> return (isReadableHandleType htype)
+#endif
 
 hIsWritable :: Handle -> IO Bool
+#if defined(ASTERIUS)
+hIsWritable = undefined
+#else
 hIsWritable (DuplexHandle _ _ _) = return True
 hIsWritable handle =
     withHandle_ "hIsWritable" handle $ \ handle_ -> do
@@ -499,11 +565,15 @@
       ClosedHandle         -> ioe_closedHandle
       SemiClosedHandle     -> ioe_semiclosedHandle
       htype                -> return (isWritableHandleType htype)
+#endif
 
 -- | Computation 'hGetBuffering' @hdl@ returns the current buffering mode
 -- for @hdl@.
 
 hGetBuffering :: Handle -> IO BufferMode
+#if defined(ASTERIUS)
+hGetBuffering = undefined
+#else
 hGetBuffering handle =
     withHandle_ "hGetBuffering" handle $ \ handle_ -> do
     case haType handle_ of
@@ -512,8 +582,12 @@
            -- We're being non-standard here, and allow the buffering
            -- of a semi-closed handle to be queried.   -- sof 6/98
           return (haBufferMode handle_)  -- could be stricter..
+#endif
 
 hIsSeekable :: Handle -> IO Bool
+#if defined(ASTERIUS)
+hIsSeekable = undefined
+#else
 hIsSeekable handle =
     withHandle_ "hIsSeekable" handle $ \ handle_@Handle__{..} -> do
     case haType of
@@ -521,6 +595,7 @@
       SemiClosedHandle     -> ioe_semiclosedHandle
       AppendHandle         -> return False
       _                    -> IODevice.isSeekable haDevice
+#endif
 
 -- -----------------------------------------------------------------------------
 -- Changing echo status
@@ -528,6 +603,9 @@
 -- | Set the echoing status of a handle connected to a terminal.
 
 hSetEcho :: Handle -> Bool -> IO ()
+#if defined(ASTERIUS)
+hSetEcho = undefined
+#else
 hSetEcho handle on = do
     isT   <- hIsTerminalDevice handle
     if not isT
@@ -537,10 +615,14 @@
       case haType of
          ClosedHandle -> ioe_closedHandle
          _            -> IODevice.setEcho haDevice on
+#endif
 
 -- | Get the echoing status of a handle connected to a terminal.
 
 hGetEcho :: Handle -> IO Bool
+#if defined(ASTERIUS)
+hGetEcho = undefined
+#else
 hGetEcho handle = do
     isT   <- hIsTerminalDevice handle
     if not isT
@@ -550,15 +632,20 @@
        case haType of
          ClosedHandle -> ioe_closedHandle
          _            -> IODevice.getEcho haDevice
+#endif
 
 -- | Is the handle connected to a terminal?
 
 hIsTerminalDevice :: Handle -> IO Bool
+#if defined(ASTERIUS)
+hIsTerminalDevice = undefined
+#else
 hIsTerminalDevice handle = do
     withHandle_ "hIsTerminalDevice" handle $ \ Handle__{..} -> do
      case haType of
        ClosedHandle -> ioe_closedHandle
        _            -> IODevice.isTerminal haDevice
+#endif
 
 -- -----------------------------------------------------------------------------
 -- hSetBinaryMode
@@ -570,6 +657,9 @@
 -- with 'hSetNewlineMode' with 'noNewlineTranslation'.
 --
 hSetBinaryMode :: Handle -> Bool -> IO ()
+#if defined(ASTERIUS)
+hSetBinaryMode = undefined
+#else
 hSetBinaryMode handle bin =
   withAllHandles__ "hSetBinaryMode" handle $ \ h_@Handle__{..} ->
     do
@@ -594,6 +684,7 @@
                           haCodec    = mb_te,
                           haInputNL  = inputNL nl,
                           haOutputNL = outputNL nl, .. }
+#endif
 
 -- -----------------------------------------------------------------------------
 -- hSetNewlineMode
@@ -601,11 +692,15 @@
 -- | Set the 'NewlineMode' on the specified 'Handle'.  All buffered
 -- data is flushed first.
 hSetNewlineMode :: Handle -> NewlineMode -> IO ()
+#if defined(ASTERIUS)
+hSetNewlineMode = undefined
+#else
 hSetNewlineMode handle NewlineMode{ inputNL=i, outputNL=o } =
   withAllHandles__ "hSetNewlineMode" handle $ \h_@Handle__{..} ->
     do
          flushBuffer h_
          return h_{ haInputNL=i, haOutputNL=o }
+#endif
 
 -- -----------------------------------------------------------------------------
 -- Duplicating a Handle
@@ -616,6 +711,9 @@
 -- before the handle is duplicated.
 
 hDuplicate :: Handle -> IO Handle
+#if defined(ASTERIUS)
+hDuplicate = undefined
+#else
 hDuplicate h@(FileHandle path m) = do
   withHandle_' "hDuplicate" h m $ \h_ ->
       dupHandle path h Nothing h_ (Just handleFinalizer)
@@ -627,7 +725,9 @@
     withHandle_' "hDuplicate" h r $ \h_ ->
         dupHandle path h (Just write_m) h_  Nothing
   return (DuplexHandle path read_m write_m)
+#endif
 
+#if !defined(ASTERIUS)
 dupHandle :: FilePath
           -> Handle
           -> Maybe (MVar Handle__)
@@ -657,6 +757,7 @@
   mkHandle new_dev filepath haType True{-buffered-} mb_codec
       NewlineMode { inputNL = haInputNL, outputNL = haOutputNL }
       mb_finalizer other_side
+#endif
 
 -- -----------------------------------------------------------------------------
 -- Replacing a Handle
@@ -672,6 +773,9 @@
 -}
 
 hDuplicateTo :: Handle -> Handle -> IO ()
+#if defined(ASTERIUS)
+hDuplicateTo = undefined
+#else
 hDuplicateTo h1@(FileHandle path m1) h2@(FileHandle _ m2)  = do
  withHandle__' "hDuplicateTo" h2 m2 $ \h2_ -> do
    _ <- hClose_help h2_
@@ -688,13 +792,16 @@
      dupHandleTo path h1 (Just w1) r2_ r1_ Nothing
 hDuplicateTo h1 _ =
   ioe_dupHandlesNotCompatible h1
+#endif
 
-
+#if !defined(ASTERIUS)
 ioe_dupHandlesNotCompatible :: Handle -> IO a
 ioe_dupHandlesNotCompatible h =
    ioException (IOError (Just h) IllegalOperation "hDuplicateTo"
                 "handles are incompatible" Nothing Nothing)
+#endif
 
+#if !defined(ASTERIUS)
 dupHandleTo :: FilePath
             -> Handle
             -> Maybe (MVar Handle__)
@@ -712,6 +819,7 @@
       _ <- IODevice.dup2 dev dev'
       FileHandle _ m <- dupHandle_ dev' filepath other_side h_ mb_finalizer
       takeMVar m
+#endif
 
 -- ---------------------------------------------------------------------------
 -- showing Handles.
@@ -720,9 +828,14 @@
 -- than the (pure) instance of 'Show' for 'Handle'.
 
 hShow :: Handle -> IO String
+#if defined(ASTERIUS)
+hShow = undefined
+#else
 hShow h@(FileHandle path _) = showHandle' path False h
 hShow h@(DuplexHandle path _ _) = showHandle' path True h
+#endif
 
+#if !defined(ASTERIUS)
 showHandle' :: String -> Bool -> Handle -> IO String
 showHandle' filepath is_duplex h =
   withHandle_ "showHandle" h $ \hdl_ ->
@@ -755,4 +868,4 @@
       where
        def :: Int
        def = bufSize buf
-
+#endif
diff -ruN -x '*.rej' -x '*.orig' old/libraries/base/GHC/Natural.hs new/libraries/base/GHC/Natural.hs
--- old/libraries/base/GHC/Natural.hs	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/base/GHC/Natural.hs	2019-05-13 13:38:31.000000000 +1200
@@ -272,11 +272,6 @@
 testBitNatural (NatJ# bn) (I# i#)      = testBitBigNat bn i#
 -- {-# CONSTANT_FOLDED testBitNatural #-}
 
-popCountNatural :: Natural -> Int
-popCountNatural (NatS# w)  = I# (word2Int# (popCnt# w))
-popCountNatural (NatJ# bn) = I# (popCountBigNat bn)
--- {-# CONSTANT_FOLDED popCountNatural #-}
-
 shiftLNatural :: Natural -> Int -> Natural
 shiftLNatural n           (I# 0#) = n
 shiftLNatural (NatS# 0##) _       = NatS# 0##
diff -ruN -x '*.rej' -x '*.orig' old/libraries/base/GHC/Show.hs new/libraries/base/GHC/Show.hs
--- old/libraries/base/GHC/Show.hs	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/base/GHC/Show.hs	2019-05-21 11:36:07.000000000 +1200
@@ -1,6 +1,6 @@
 {-# LANGUAGE Trustworthy #-}
 {-# LANGUAGE CPP, NoImplicitPrelude, BangPatterns, StandaloneDeriving,
-             MagicHash, UnboxedTuples #-}
+             MagicHash, UnboxedTuples, UnliftedFFITypes #-}
 {-# OPTIONS_HADDOCK hide #-}
 
 #include "MachDeps.h"
@@ -55,6 +55,11 @@
 import GHC.Stack.Types
 import GHC.Types (TypeLitSort (..))
 
+#if defined(ASTERIUS)
+import Asterius.Magic
+import GHC.Integer.Simple.Internals
+import GHC.Prim
+#endif
 
 -- | The @shows@ functions return a function that prepends the
 -- output 'String' to an existing 'String'.  This allows constant-time
@@ -488,6 +493,16 @@
 
 -- Divide and conquer implementation of string conversion
 integerToString :: Integer -> String -> String
+#if defined(ASTERIUS)
+
+integerToString (Integer i) s =
+  accursedUnutterableAddrToAny
+    (js_integerToString i (accursedUnutterableAnyToAddr s))
+
+foreign import javascript "__asterius_jsffi.Integer.integerToString(${1},${2})" js_integerToString
+  :: Int# -> Addr# -> Addr#
+
+#else
 integerToString n0 cs0
     | n0 < 0    = '-' : integerToString' (- n0) cs0
     | otherwise = integerToString' n0 cs0
@@ -564,6 +579,7 @@
              c@(C# _) -> jblock' (d - 1) q (c : cs)
         where
         (q, r) = n `quotRemInt` 10
+#endif
 
 instance Show KindRep where
   showsPrec d (KindRepVar v) = showParen (d > 10) $
diff -ruN -x '*.rej' -x '*.orig' old/libraries/base/base.cabal new/libraries/base/base.cabal
--- old/libraries/base/base.cabal	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/base/base.cabal	2019-05-13 13:38:36.000000000 +1200
@@ -319,6 +319,9 @@
         Type.Reflection.Unsafe
         Unsafe.Coerce
 
+        Asterius.Prim
+        Asterius.Types
+
     other-modules:
         Control.Monad.ST.Imp
         Control.Monad.ST.Lazy.Imp
diff -ruN -x '*.rej' -x '*.orig' old/libraries/base/cbits/fs.c new/libraries/base/cbits/fs.c
--- old/libraries/base/cbits/fs.c	1970-01-01 12:00:00.000000000 +1200
+++ new/libraries/base/cbits/fs.c	2019-05-13 13:38:36.000000000 +1200
@@ -0,0 +1,291 @@
+/* -----------------------------------------------------------------------------
+ *
+ * (c) Tamar Christina 2018
+ *
+ * Windows I/O routines for file opening.
+ *
+ * NOTE: Only modify this file in utils/fs/ and rerun configure. Do not edit
+ *       this file in any other directory as it will be overwritten.
+ *
+ * ---------------------------------------------------------------------------*/
+#include "fs.h"
+#include <stdio.h>
+
+#if defined(_WIN32)
+
+#include <stdbool.h>
+#include <stdlib.h>
+#include <stdint.h>
+
+#include <windows.h>
+#include <io.h>
+#include <fcntl.h>
+#include <wchar.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <share.h>
+
+/* This function converts Windows paths between namespaces. More specifically
+   It converts an explorer style path into a NT or Win32 namespace.
+   This has several caveats but they are caviats that are native to Windows and
+   not POSIX. See
+   https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx.
+   Anything else such as raw device paths we leave untouched.  The main benefit
+   of doing any of this is that we can break the MAX_PATH restriction and also
+   access raw handles that we couldn't before.  */
+static wchar_t* __hs_create_device_name (const wchar_t* filename) {
+  const wchar_t* win32_dev_namespace  = L"\\\\.\\";
+  const wchar_t* win32_file_namespace = L"\\\\?\\";
+  const wchar_t* nt_device_namespace  = L"\\Device\\";
+  const wchar_t* unc_prefix           = L"UNC\\";
+  const wchar_t* network_share        = L"\\\\";
+
+  wchar_t* result = _wcsdup (filename);
+  wchar_t ns[10] = {0};
+
+  /* If the file is already in a native namespace don't change it.  */
+  if (   wcsncmp (win32_dev_namespace , filename, 4) == 0
+      || wcsncmp (win32_file_namespace, filename, 4) == 0
+      || wcsncmp (nt_device_namespace , filename, 8) == 0)
+    return result;
+
+  /* Since we're using the lower level APIs we must normalize slashes now.  The
+     Win32 API layer will no longer convert '/' into '\\' for us.  */
+  for (size_t i = 0; i < wcslen (result); i++)
+    {
+      if (result[i] == L'/')
+        result[i] = L'\\';
+    }
+
+  /* Now resolve any . and .. in the path or subsequent API calls may fail since
+     Win32 will no longer resolve them.  */
+  DWORD nResult = GetFullPathNameW (result, 0, NULL, NULL) + 1;
+  wchar_t *temp = _wcsdup (result);
+  result = malloc (nResult * sizeof (wchar_t));
+  if (GetFullPathNameW (temp, nResult, result, NULL) == 0)
+    {
+      goto cleanup;
+    }
+
+  free (temp);
+
+  if (wcsncmp (network_share, result, 2) == 0)
+    {
+      if (swprintf (ns, 10, L"%ls%ls", win32_file_namespace, unc_prefix) <= 0)
+        {
+          goto cleanup;
+        }
+    }
+  else if (swprintf (ns, 10, L"%ls", win32_file_namespace) <= 0)
+    {
+      goto cleanup;
+    }
+
+  /* Create new string.  */
+  int bLen = wcslen (result) + wcslen (ns) + 1;
+  temp = _wcsdup (result);
+  result = malloc (bLen * sizeof (wchar_t));
+  if (swprintf (result, bLen, L"%ls%ls", ns, temp) <= 0)
+    {
+      goto cleanup;
+    }
+
+  free (temp);
+
+  return result;
+
+cleanup:
+  free (temp);
+  free (result);
+  return NULL;
+}
+
+#define HAS_FLAG(a,b) ((a & b) == b)
+
+int FS(swopen) (const wchar_t* filename, int oflag, int shflag, int pmode)
+{
+  /* Construct access mode.  */
+  DWORD dwDesiredAccess = 0;
+  if (HAS_FLAG (oflag, _O_RDONLY))
+    dwDesiredAccess |= GENERIC_READ | FILE_READ_DATA | FILE_READ_ATTRIBUTES;
+  if (HAS_FLAG (oflag, _O_RDWR))
+    dwDesiredAccess |= GENERIC_WRITE | GENERIC_READ | FILE_READ_DATA |
+                       FILE_WRITE_DATA | FILE_READ_ATTRIBUTES |
+                       FILE_WRITE_ATTRIBUTES;
+  if (HAS_FLAG (oflag,  _O_WRONLY))
+    dwDesiredAccess|= GENERIC_WRITE | FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES;
+
+  /* Construct shared mode.  */
+  DWORD dwShareMode = FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE;
+  if (HAS_FLAG (shflag, _SH_DENYRW))
+    dwShareMode &= ~(FILE_SHARE_READ | FILE_SHARE_WRITE);
+  if (HAS_FLAG (shflag, _SH_DENYWR))
+    dwShareMode &= ~FILE_SHARE_WRITE;
+  if (HAS_FLAG (shflag, _SH_DENYRD))
+    dwShareMode &= ~FILE_SHARE_READ;
+  if (HAS_FLAG (pmode, _S_IWRITE))
+    dwShareMode |= FILE_SHARE_READ | FILE_SHARE_WRITE;
+  if (HAS_FLAG (pmode, _S_IREAD))
+    dwShareMode |= FILE_SHARE_READ;
+
+  /* Override access mode with pmode if creating file.  */
+  if (HAS_FLAG (oflag, _O_CREAT))
+    {
+      if (HAS_FLAG (pmode, _S_IWRITE))
+        dwDesiredAccess |= FILE_GENERIC_WRITE;
+      if (HAS_FLAG (pmode, _S_IREAD))
+        dwDesiredAccess |= FILE_GENERIC_READ;
+    }
+
+  /* Create file disposition.  */
+  DWORD dwCreationDisposition = OPEN_EXISTING;
+  if (HAS_FLAG (oflag, _O_CREAT))
+    dwCreationDisposition = OPEN_ALWAYS;
+  if (HAS_FLAG (oflag, (_O_CREAT | _O_EXCL)))
+    dwCreationDisposition = CREATE_NEW;
+  if (HAS_FLAG (oflag, _O_TRUNC) && !HAS_FLAG (oflag, _O_CREAT))
+    dwCreationDisposition = TRUNCATE_EXISTING;
+
+  /* Set file access attributes.  */
+  DWORD dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
+  if (HAS_FLAG (oflag, _O_RDONLY))
+    dwFlagsAndAttributes |= 0; /* No special attribute.  */
+  if (HAS_FLAG (oflag, (_O_CREAT | _O_TEMPORARY)))
+    dwFlagsAndAttributes |= FILE_FLAG_DELETE_ON_CLOSE;
+  if (HAS_FLAG (oflag, (_O_CREAT | _O_SHORT_LIVED)))
+    dwFlagsAndAttributes |= FILE_ATTRIBUTE_TEMPORARY;
+  if (HAS_FLAG (oflag, _O_RANDOM))
+    dwFlagsAndAttributes |= FILE_FLAG_RANDOM_ACCESS;
+  if (HAS_FLAG (oflag, _O_SEQUENTIAL))
+    dwFlagsAndAttributes |= FILE_FLAG_SEQUENTIAL_SCAN;
+  /* Flag is only valid on it's own.  */
+  if (dwFlagsAndAttributes != FILE_ATTRIBUTE_NORMAL)
+    dwFlagsAndAttributes &= ~FILE_ATTRIBUTE_NORMAL;
+
+  /* Set security attributes.  */
+  SECURITY_ATTRIBUTES securityAttributes;
+  ZeroMemory (&securityAttributes, sizeof(SECURITY_ATTRIBUTES));
+  securityAttributes.bInheritHandle       = !(oflag & _O_NOINHERIT);
+  securityAttributes.lpSecurityDescriptor = NULL;
+  securityAttributes.nLength              = sizeof(SECURITY_ATTRIBUTES);
+
+  wchar_t* _filename = __hs_create_device_name (filename);
+  if (!_filename)
+    return -1;
+
+  HANDLE hResult
+    = CreateFileW (_filename, dwDesiredAccess, dwShareMode, &securityAttributes,
+                   dwCreationDisposition, dwFlagsAndAttributes, NULL);
+  free (_filename);
+  if (INVALID_HANDLE_VALUE == hResult)
+    return -1;
+
+  /* Now we have a Windows handle, we have to convert it to an FD and apply
+     the remaining flags.  */
+  const int flag_mask = _O_APPEND | _O_RDONLY | _O_TEXT | _O_WTEXT;
+  int fd = _open_osfhandle ((intptr_t)hResult, oflag & flag_mask);
+  if (-1 == fd)
+    return -1;
+
+  /* Finally we can change the mode to the requested one.  */
+  const int mode_mask = _O_TEXT | _O_BINARY | _O_U16TEXT | _O_U8TEXT | _O_WTEXT;
+  if ((oflag & mode_mask) && (-1 == _setmode (fd, oflag & mode_mask)))
+    return -1;
+
+  return fd;
+}
+
+FILE *FS(fwopen) (const wchar_t* filename, const wchar_t* mode)
+{
+  int shflag = 0;
+  int pmode  = 0;
+  int oflag  = 0;
+
+  int len = wcslen (mode);
+  int i;
+  #define IS_EXT(X) ((i < (len - 1)) && mode[i] == X)
+
+  for (i = 0; i < len; i++)
+    {
+      switch (mode[i])
+        {
+          case L'a':
+            if (IS_EXT (L'+'))
+              oflag |= _O_RDWR | _O_CREAT | _O_APPEND;
+            else
+              oflag |= _O_WRONLY | _O_CREAT | _O_APPEND;
+            break;
+          case L'r':
+            if (IS_EXT (L'+'))
+              oflag |= _O_RDWR;
+            else
+              oflag |= _O_RDONLY;
+            break;
+          case L'w':
+            if (IS_EXT (L'+'))
+              oflag |= _O_RDWR | _O_CREAT | _O_TRUNC;
+            else
+              oflag |= _O_WRONLY | _O_CREAT | _O_TRUNC;
+            break;
+          case L'b':
+            oflag |= _O_BINARY;
+            break;
+          case L't':
+            oflag |= _O_TEXT;
+            break;
+          case L'c':
+          case L'n':
+            oflag |= 0;
+            break;
+          case L'S':
+            oflag |= _O_SEQUENTIAL;
+            break;
+          case L'R':
+            oflag |= _O_RANDOM;
+            break;
+          case L'T':
+            oflag |= _O_SHORT_LIVED;
+            break;
+          case L'D':
+            oflag |= _O_TEMPORARY;
+            break;
+          default:
+            if (wcsncmp (mode, L"ccs=UNICODE", 11) == 0)
+              oflag |= _O_WTEXT;
+            else if (wcsncmp (mode, L"ccs=UTF-8", 9) == 0)
+              oflag |= _O_U8TEXT;
+            else if (wcsncmp (mode, L"ccs=UTF-16LE", 12) == 0)
+              oflag |= _O_U16TEXT;
+            else continue;
+        }
+    }
+  #undef IS_EXT
+
+  int fd = FS(swopen) (filename, oflag, shflag, pmode);
+  FILE* file = _wfdopen (fd, mode);
+  return file;
+}
+
+FILE *FS(fopen) (const char* filename, const char* mode)
+{
+  size_t len = mbstowcs (NULL, filename, 0);
+  wchar_t *w_filename = malloc (sizeof (wchar_t) * (len + 1));
+  mbstowcs (w_filename, filename, len);
+  w_filename[len] = L'\0';
+
+  len = mbstowcs (NULL, mode, 0);
+  wchar_t *w_mode = malloc (sizeof (wchar_t) * (len + 1));
+  mbstowcs (w_mode, mode, len);
+  w_mode[len] = L'\0';
+
+  FILE *result = FS(fwopen) (w_filename, w_mode);
+  free (w_filename);
+  free (w_mode);
+  return result;
+}
+#else
+FILE *FS(fopen) (const char* filename, const char* mode)
+{
+  return fopen (filename, mode);
+}
+#endif
diff -ruN -x '*.rej' -x '*.orig' old/libraries/base/configure.ac new/libraries/base/configure.ac
--- old/libraries/base/configure.ac	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/base/configure.ac	2019-05-13 13:38:36.000000000 +1200
@@ -237,7 +237,7 @@
 CFLAGS="-I../.. -I../../../../includes $CFLAGS"
 dnl Calling AC_CHECK_TYPE(T) makes AC_CHECK_SIZEOF(T) abort on failure
 dnl instead of considering sizeof(T) as 0.
-AC_CHECK_TYPE([struct MD5Context], [], [AC_MSG_ERROR([internal error])], [#include "include/md5.h"])
+AC_CHECK_TYPE([struct MD5Context], [], [], [#include "include/md5.h"])
 AC_CHECK_SIZEOF([struct MD5Context], [], [#include "include/md5.h"])
 
 AC_SUBST(EXTRA_LIBS)
diff -ruN -x '*.rej' -x '*.orig' old/libraries/base/include/fs.h new/libraries/base/include/fs.h
--- old/libraries/base/include/fs.h	1970-01-01 12:00:00.000000000 +1200
+++ new/libraries/base/include/fs.h	2019-05-13 13:38:36.000000000 +1200
@@ -0,0 +1,36 @@
+/* -----------------------------------------------------------------------------
+ *
+ * (c) Tamar Christina 2018
+ *
+ * Windows I/O routines for file opening.
+ *
+ * NOTE: Only modify this file in utils/fs/ and rerun configure. Do not edit
+ *       this file in any other directory as it will be overwritten.
+ *
+ * ---------------------------------------------------------------------------*/
+
+#pragma once
+
+#include <stdio.h>
+
+#if !defined(FS_NAMESPACE)
+#define FS_NAMESPACE hs
+#endif
+
+/* Play some dirty tricks to get CPP to expand correctly.  */
+#define FS_FULL(ns, name) __##ns##_##name
+#define prefix FS_NAMESPACE
+#define FS_L(p, n) FS_FULL(p, n)
+#define FS(name) FS_L(prefix, name)
+
+#if defined(_WIN32)
+#include <wchar.h>
+
+int FS(swopen) (const wchar_t* filename, int oflag,
+                int shflag, int pmode);
+FILE *FS(fwopen) (const wchar_t* filename, const wchar_t* mode);
+FILE *FS(fopen) (const char* filename, const char* mode);
+#else
+
+FILE *FS(fopen) (const char* filename, const char* mode);
+#endif
diff -ruN -x '*.rej' -x '*.orig' old/libraries/bytestring/Asterius/ByteString.hs new/libraries/bytestring/Asterius/ByteString.hs
--- old/libraries/bytestring/Asterius/ByteString.hs	1970-01-01 12:00:00.000000000 +1200
+++ new/libraries/bytestring/Asterius/ByteString.hs	2019-05-13 13:38:36.000000000 +1200
@@ -0,0 +1,39 @@
+{-# LANGUAGE MagicHash #-}
+
+module Asterius.ByteString
+  ( foreignPtrFromJSArrayBuffer
+  , byteStringFromJSArrayBuffer
+  , byteStringToJSArrayBuffer
+  ) where
+
+import Asterius.Magic
+import Asterius.Types
+import Data.ByteString.Internal (ByteString(..))
+import Data.ByteString.Unsafe
+import GHC.Base
+import GHC.ForeignPtr
+import GHC.IO
+import GHC.Ptr
+
+{-# INLINE foreignPtrFromJSArrayBuffer #-}
+foreignPtrFromJSArrayBuffer :: JSArrayBuffer -> ForeignPtr a
+foreignPtrFromJSArrayBuffer buf =
+  case fromJSArrayBuffer buf of
+    ba -> ForeignPtr (byteArrayContents# ba) (PlainPtr (unsafeCoerce# ba))
+
+{-# INLINE byteStringFromJSArrayBuffer #-}
+byteStringFromJSArrayBuffer :: JSArrayBuffer -> ByteString
+byteStringFromJSArrayBuffer buf =
+  case fromJSArrayBuffer buf of
+    ba ->
+      PS
+        (ForeignPtr (byteArrayContents# ba) (PlainPtr (unsafeCoerce# ba)))
+        0
+        (I# (sizeofByteArray# ba))
+
+{-# INLINE byteStringToJSArrayBuffer #-}
+byteStringToJSArrayBuffer :: ByteString -> JSArrayBuffer
+byteStringToJSArrayBuffer bs =
+  accursedUnutterablePerformIO $
+  unsafeUseAsCStringLen bs $ \(Ptr addr, len) ->
+    evaluate $ toJSArrayBuffer addr len
diff -ruN -x '*.rej' -x '*.orig' old/libraries/bytestring/Data/ByteString/Builder/Internal.hs new/libraries/bytestring/Data/ByteString/Builder/Internal.hs
--- old/libraries/bytestring/Data/ByteString/Builder/Internal.hs	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/bytestring/Data/ByteString/Builder/Internal.hs	2019-05-13 13:38:36.000000000 +1200
@@ -149,8 +149,10 @@
 
 #if __GLASGOW_HASKELL__ >= 611
 import qualified GHC.IO.Buffer as IO (Buffer(..), newByteBuffer)
+#if !defined(ASTERIUS)
 import           GHC.IO.Handle.Internals (wantWritableHandle, flushWriteBuffer)
 import           GHC.IO.Handle.Types (Handle__, haByteBuffer, haBufferMode)
+#endif
 import           System.IO (hFlush, BufferMode(..))
 import           Data.IORef
 #else
@@ -612,6 +614,9 @@
 -- buffer is too small to execute one step of the 'Put' action, then
 -- it is replaced with a large enough buffer.
 hPut :: forall a. Handle -> Put a -> IO a
+#if defined(ASTERIUS)
+hPut = undefined
+#else
 #if __GLASGOW_HASKELL__ >= 611
 hPut h p = do
     fillHandle 1 (runPut p)
@@ -722,6 +727,7 @@
     go (Finished buf x) = S.hPut h (byteStringFromBuffer buf) >> return x
     go (Yield1 bs io)   = S.hPut h bs >> io >>= go
 #endif
+#endif
 
 -- | Execute a 'Put' and return the computed result and the bytes
 -- written during the computation as a lazy 'L.ByteString'.
diff -ruN -x '*.rej' -x '*.orig' old/libraries/bytestring/Data/ByteString/Internal.hs new/libraries/bytestring/Data/ByteString/Internal.hs
--- old/libraries/bytestring/Data/ByteString/Internal.hs	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/bytestring/Data/ByteString/Internal.hs	2019-05-13 13:38:36.000000000 +1200
@@ -119,6 +119,7 @@
 #endif
 
 import GHC.Prim                 (Addr#)
+import GHC.Magic                (runRW#)
 
 #if __GLASGOW_HASKELL__ >= 611
 import GHC.IO                   (IO(IO),unsafeDupablePerformIO)
@@ -589,7 +590,7 @@
 --
 {-# INLINE accursedUnutterablePerformIO #-}
 accursedUnutterablePerformIO :: IO a -> a
-accursedUnutterablePerformIO (IO m) = case m realWorld# of (# _, r #) -> r
+accursedUnutterablePerformIO (IO m) = case runRW# m of (# _, r #) -> r
 
 inlinePerformIO :: IO a -> a
 inlinePerformIO = accursedUnutterablePerformIO
diff -ruN -x '*.rej' -x '*.orig' old/libraries/bytestring/Data/ByteString.hs new/libraries/bytestring/Data/ByteString.hs
--- old/libraries/bytestring/Data/ByteString.hs	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/bytestring/Data/ByteString.hs	2019-05-13 13:38:36.000000000 +1200
@@ -1598,6 +1598,9 @@
 -- | Read a line from a handle
 
 hGetLine :: Handle -> IO ByteString
+#if defined(ASTERIUS)
+hGetLine = undefined
+#else
 hGetLine h =
   wantReadableHandle_ "Data.ByteString.hGetLine" h $
     \ h_@Handle__{haByteBuffer} -> do
@@ -1642,6 +1645,7 @@
             if c == fromIntegral (ord '\n')
                 then return r -- NB. not r+1: don't include the '\n'
                 else findEOL (r+1) w raw
+#endif
 
 mkPS :: RawBuffer Word8 -> Int -> Int -> IO ByteString
 mkPS buf start end =
diff -ruN -x '*.rej' -x '*.orig' old/libraries/bytestring/bytestring.cabal new/libraries/bytestring/bytestring.cabal
--- old/libraries/bytestring/bytestring.cabal	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/bytestring/bytestring.cabal	2019-05-13 13:38:36.000000000 +1200
@@ -93,6 +93,8 @@
                      Data.ByteString.Lazy.Builder
                      Data.ByteString.Lazy.Builder.Extras
                      Data.ByteString.Lazy.Builder.ASCII
+
+                     Asterius.ByteString
   other-modules:
                      Data.ByteString.Builder.ASCII
                      Data.ByteString.Builder.Prim.Binary
diff -ruN -x '*.rej' -x '*.orig' old/libraries/ghc-prim/Asterius/Magic.hs new/libraries/ghc-prim/Asterius/Magic.hs
--- old/libraries/ghc-prim/Asterius/Magic.hs	1970-01-01 12:00:00.000000000 +1200
+++ new/libraries/ghc-prim/Asterius/Magic.hs	2019-05-13 13:38:44.000000000 +1200
@@ -0,0 +1,63 @@
+{-# LANGUAGE MagicHash #-}
+{-# LANGUAGE NoImplicitPrelude #-}
+{-# LANGUAGE PolyKinds #-}
+{-# LANGUAGE UnboxedTuples #-}
+
+module Asterius.Magic
+  ( accursedUnutterableAddrToAny
+  , accursedUnutterableAnyToAddr
+  , accursedUnutterablePerformIO
+  , unIO
+  , unI#
+  , unW#
+  , unF#
+  , unD#
+  , unBool
+  ) where
+
+import GHC.Magic
+import GHC.Prim
+import GHC.Types
+
+{-# INLINE accursedUnutterableAddrToAny #-}
+accursedUnutterableAddrToAny :: Addr# -> (a :: TYPE r)
+accursedUnutterableAddrToAny = unsafeCoerce#
+
+{-# INLINE accursedUnutterableAnyToAddr #-}
+accursedUnutterableAnyToAddr :: a -> Addr#
+accursedUnutterableAnyToAddr a =
+  runRW#
+    (\s0 ->
+       case anyToAddr# a s0 of
+         (# _, addr #) -> addr)
+
+{-# INLINE accursedUnutterablePerformIO #-}
+accursedUnutterablePerformIO :: IO a -> a
+accursedUnutterablePerformIO (IO m) =
+  case runRW# m of
+    (# _, a #) -> a
+
+{-# INLINE unIO #-}
+unIO :: IO a -> State# RealWorld -> (# State# RealWorld, a #)
+unIO (IO m) = m
+
+{-# INLINE unI# #-}
+unI# :: Int -> Int#
+unI# (I# i) = i
+
+{-# INLINE unW# #-}
+unW# :: Word -> Word#
+unW# (W# w) = w
+
+{-# INLINE unF# #-}
+unF# :: Float -> Float#
+unF# (F# f) = f
+
+{-# INLINE unD# #-}
+unD# :: Double -> Double#
+unD# (D# d) = d
+
+{-# INLINE unBool #-}
+unBool :: Bool -> Int#
+unBool False = 0#
+unBool True = 1#
diff -ruN -x '*.rej' -x '*.orig' old/libraries/ghc-prim/GHC/PrimopWrappers.hs new/libraries/ghc-prim/GHC/PrimopWrappers.hs
--- old/libraries/ghc-prim/GHC/PrimopWrappers.hs	1970-01-01 12:00:00.000000000 +1200
+++ new/libraries/ghc-prim/GHC/PrimopWrappers.hs	2019-05-13 13:38:44.000000000 +1200
@@ -0,0 +1,1682 @@
+{-# LANGUAGE CPP, MagicHash, NoImplicitPrelude, UnboxedTuples #-}
+{-# OPTIONS_GHC -Wno-deprecations -O0 #-}
+module GHC.PrimopWrappers where
+import qualified GHC.Prim
+import GHC.Tuple ()
+import GHC.Prim (Char#, Int#, Word#, Float#, Double#, Int8#, Word8#, Int16#, Word16#, State#, MutableArray#, Array#, SmallMutableArray#, SmallArray#, MutableByteArray#, ByteArray#, Addr#, StablePtr#, MutableArrayArray#, ArrayArray#, MutVar#, RealWorld, TVar#, MVar#, ThreadId#, Weak#, StableName#, Compact#, BCO#)
+{-# NOINLINE gtChar# #-}
+gtChar# :: Char# -> Char# -> Int#
+gtChar# a1 a2 = (GHC.Prim.gtChar#) a1 a2
+{-# NOINLINE geChar# #-}
+geChar# :: Char# -> Char# -> Int#
+geChar# a1 a2 = (GHC.Prim.geChar#) a1 a2
+{-# NOINLINE eqChar# #-}
+eqChar# :: Char# -> Char# -> Int#
+eqChar# a1 a2 = (GHC.Prim.eqChar#) a1 a2
+{-# NOINLINE neChar# #-}
+neChar# :: Char# -> Char# -> Int#
+neChar# a1 a2 = (GHC.Prim.neChar#) a1 a2
+{-# NOINLINE ltChar# #-}
+ltChar# :: Char# -> Char# -> Int#
+ltChar# a1 a2 = (GHC.Prim.ltChar#) a1 a2
+{-# NOINLINE leChar# #-}
+leChar# :: Char# -> Char# -> Int#
+leChar# a1 a2 = (GHC.Prim.leChar#) a1 a2
+{-# NOINLINE ord# #-}
+ord# :: Char# -> Int#
+ord# a1 = (GHC.Prim.ord#) a1
+{-# NOINLINE (+#) #-}
+(+#) :: Int# -> Int# -> Int#
+(+#) a1 a2 = (GHC.Prim.+#) a1 a2
+{-# NOINLINE (-#) #-}
+(-#) :: Int# -> Int# -> Int#
+(-#) a1 a2 = (GHC.Prim.-#) a1 a2
+{-# NOINLINE (*#) #-}
+(*#) :: Int# -> Int# -> Int#
+(*#) a1 a2 = (GHC.Prim.*#) a1 a2
+{-# NOINLINE mulIntMayOflo# #-}
+mulIntMayOflo# :: Int# -> Int# -> Int#
+mulIntMayOflo# a1 a2 = (GHC.Prim.mulIntMayOflo#) a1 a2
+{-# NOINLINE quotInt# #-}
+quotInt# :: Int# -> Int# -> Int#
+quotInt# a1 a2 = (GHC.Prim.quotInt#) a1 a2
+{-# NOINLINE remInt# #-}
+remInt# :: Int# -> Int# -> Int#
+remInt# a1 a2 = (GHC.Prim.remInt#) a1 a2
+{-# NOINLINE quotRemInt# #-}
+quotRemInt# :: Int# -> Int# -> (# Int#,Int# #)
+quotRemInt# a1 a2 = (GHC.Prim.quotRemInt#) a1 a2
+{-# NOINLINE andI# #-}
+andI# :: Int# -> Int# -> Int#
+andI# a1 a2 = (GHC.Prim.andI#) a1 a2
+{-# NOINLINE orI# #-}
+orI# :: Int# -> Int# -> Int#
+orI# a1 a2 = (GHC.Prim.orI#) a1 a2
+{-# NOINLINE xorI# #-}
+xorI# :: Int# -> Int# -> Int#
+xorI# a1 a2 = (GHC.Prim.xorI#) a1 a2
+{-# NOINLINE notI# #-}
+notI# :: Int# -> Int#
+notI# a1 = (GHC.Prim.notI#) a1
+{-# NOINLINE negateInt# #-}
+negateInt# :: Int# -> Int#
+negateInt# a1 = (GHC.Prim.negateInt#) a1
+{-# NOINLINE addIntC# #-}
+addIntC# :: Int# -> Int# -> (# Int#,Int# #)
+addIntC# a1 a2 = (GHC.Prim.addIntC#) a1 a2
+{-# NOINLINE subIntC# #-}
+subIntC# :: Int# -> Int# -> (# Int#,Int# #)
+subIntC# a1 a2 = (GHC.Prim.subIntC#) a1 a2
+{-# NOINLINE (>#) #-}
+(>#) :: Int# -> Int# -> Int#
+(>#) a1 a2 = (GHC.Prim.>#) a1 a2
+{-# NOINLINE (>=#) #-}
+(>=#) :: Int# -> Int# -> Int#
+(>=#) a1 a2 = (GHC.Prim.>=#) a1 a2
+{-# NOINLINE (==#) #-}
+(==#) :: Int# -> Int# -> Int#
+(==#) a1 a2 = (GHC.Prim.==#) a1 a2
+{-# NOINLINE (/=#) #-}
+(/=#) :: Int# -> Int# -> Int#
+(/=#) a1 a2 = (GHC.Prim./=#) a1 a2
+{-# NOINLINE (<#) #-}
+(<#) :: Int# -> Int# -> Int#
+(<#) a1 a2 = (GHC.Prim.<#) a1 a2
+{-# NOINLINE (<=#) #-}
+(<=#) :: Int# -> Int# -> Int#
+(<=#) a1 a2 = (GHC.Prim.<=#) a1 a2
+{-# NOINLINE chr# #-}
+chr# :: Int# -> Char#
+chr# a1 = (GHC.Prim.chr#) a1
+{-# NOINLINE int2Word# #-}
+int2Word# :: Int# -> Word#
+int2Word# a1 = (GHC.Prim.int2Word#) a1
+{-# NOINLINE int2Float# #-}
+int2Float# :: Int# -> Float#
+int2Float# a1 = (GHC.Prim.int2Float#) a1
+{-# NOINLINE int2Double# #-}
+int2Double# :: Int# -> Double#
+int2Double# a1 = (GHC.Prim.int2Double#) a1
+{-# NOINLINE word2Float# #-}
+word2Float# :: Word# -> Float#
+word2Float# a1 = (GHC.Prim.word2Float#) a1
+{-# NOINLINE word2Double# #-}
+word2Double# :: Word# -> Double#
+word2Double# a1 = (GHC.Prim.word2Double#) a1
+{-# NOINLINE uncheckedIShiftL# #-}
+uncheckedIShiftL# :: Int# -> Int# -> Int#
+uncheckedIShiftL# a1 a2 = (GHC.Prim.uncheckedIShiftL#) a1 a2
+{-# NOINLINE uncheckedIShiftRA# #-}
+uncheckedIShiftRA# :: Int# -> Int# -> Int#
+uncheckedIShiftRA# a1 a2 = (GHC.Prim.uncheckedIShiftRA#) a1 a2
+{-# NOINLINE uncheckedIShiftRL# #-}
+uncheckedIShiftRL# :: Int# -> Int# -> Int#
+uncheckedIShiftRL# a1 a2 = (GHC.Prim.uncheckedIShiftRL#) a1 a2
+{-# NOINLINE extendInt8# #-}
+extendInt8# :: Int8# -> Int#
+extendInt8# a1 = (GHC.Prim.extendInt8#) a1
+{-# NOINLINE narrowInt8# #-}
+narrowInt8# :: Int# -> Int8#
+narrowInt8# a1 = (GHC.Prim.narrowInt8#) a1
+{-# NOINLINE negateInt8# #-}
+negateInt8# :: Int8# -> Int8#
+negateInt8# a1 = (GHC.Prim.negateInt8#) a1
+{-# NOINLINE plusInt8# #-}
+plusInt8# :: Int8# -> Int8# -> Int8#
+plusInt8# a1 a2 = (GHC.Prim.plusInt8#) a1 a2
+{-# NOINLINE subInt8# #-}
+subInt8# :: Int8# -> Int8# -> Int8#
+subInt8# a1 a2 = (GHC.Prim.subInt8#) a1 a2
+{-# NOINLINE timesInt8# #-}
+timesInt8# :: Int8# -> Int8# -> Int8#
+timesInt8# a1 a2 = (GHC.Prim.timesInt8#) a1 a2
+{-# NOINLINE quotInt8# #-}
+quotInt8# :: Int8# -> Int8# -> Int8#
+quotInt8# a1 a2 = (GHC.Prim.quotInt8#) a1 a2
+{-# NOINLINE remInt8# #-}
+remInt8# :: Int8# -> Int8# -> Int8#
+remInt8# a1 a2 = (GHC.Prim.remInt8#) a1 a2
+{-# NOINLINE quotRemInt8# #-}
+quotRemInt8# :: Int8# -> Int8# -> (# Int8#,Int8# #)
+quotRemInt8# a1 a2 = (GHC.Prim.quotRemInt8#) a1 a2
+{-# NOINLINE eqInt8# #-}
+eqInt8# :: Int8# -> Int8# -> Int#
+eqInt8# a1 a2 = (GHC.Prim.eqInt8#) a1 a2
+{-# NOINLINE geInt8# #-}
+geInt8# :: Int8# -> Int8# -> Int#
+geInt8# a1 a2 = (GHC.Prim.geInt8#) a1 a2
+{-# NOINLINE gtInt8# #-}
+gtInt8# :: Int8# -> Int8# -> Int#
+gtInt8# a1 a2 = (GHC.Prim.gtInt8#) a1 a2
+{-# NOINLINE leInt8# #-}
+leInt8# :: Int8# -> Int8# -> Int#
+leInt8# a1 a2 = (GHC.Prim.leInt8#) a1 a2
+{-# NOINLINE ltInt8# #-}
+ltInt8# :: Int8# -> Int8# -> Int#
+ltInt8# a1 a2 = (GHC.Prim.ltInt8#) a1 a2
+{-# NOINLINE neInt8# #-}
+neInt8# :: Int8# -> Int8# -> Int#
+neInt8# a1 a2 = (GHC.Prim.neInt8#) a1 a2
+{-# NOINLINE extendWord8# #-}
+extendWord8# :: Word8# -> Word#
+extendWord8# a1 = (GHC.Prim.extendWord8#) a1
+{-# NOINLINE narrowWord8# #-}
+narrowWord8# :: Word# -> Word8#
+narrowWord8# a1 = (GHC.Prim.narrowWord8#) a1
+{-# NOINLINE notWord8# #-}
+notWord8# :: Word8# -> Word8#
+notWord8# a1 = (GHC.Prim.notWord8#) a1
+{-# NOINLINE plusWord8# #-}
+plusWord8# :: Word8# -> Word8# -> Word8#
+plusWord8# a1 a2 = (GHC.Prim.plusWord8#) a1 a2
+{-# NOINLINE subWord8# #-}
+subWord8# :: Word8# -> Word8# -> Word8#
+subWord8# a1 a2 = (GHC.Prim.subWord8#) a1 a2
+{-# NOINLINE timesWord8# #-}
+timesWord8# :: Word8# -> Word8# -> Word8#
+timesWord8# a1 a2 = (GHC.Prim.timesWord8#) a1 a2
+{-# NOINLINE quotWord8# #-}
+quotWord8# :: Word8# -> Word8# -> Word8#
+quotWord8# a1 a2 = (GHC.Prim.quotWord8#) a1 a2
+{-# NOINLINE remWord8# #-}
+remWord8# :: Word8# -> Word8# -> Word8#
+remWord8# a1 a2 = (GHC.Prim.remWord8#) a1 a2
+{-# NOINLINE quotRemWord8# #-}
+quotRemWord8# :: Word8# -> Word8# -> (# Word8#,Word8# #)
+quotRemWord8# a1 a2 = (GHC.Prim.quotRemWord8#) a1 a2
+{-# NOINLINE eqWord8# #-}
+eqWord8# :: Word8# -> Word8# -> Int#
+eqWord8# a1 a2 = (GHC.Prim.eqWord8#) a1 a2
+{-# NOINLINE geWord8# #-}
+geWord8# :: Word8# -> Word8# -> Int#
+geWord8# a1 a2 = (GHC.Prim.geWord8#) a1 a2
+{-# NOINLINE gtWord8# #-}
+gtWord8# :: Word8# -> Word8# -> Int#
+gtWord8# a1 a2 = (GHC.Prim.gtWord8#) a1 a2
+{-# NOINLINE leWord8# #-}
+leWord8# :: Word8# -> Word8# -> Int#
+leWord8# a1 a2 = (GHC.Prim.leWord8#) a1 a2
+{-# NOINLINE ltWord8# #-}
+ltWord8# :: Word8# -> Word8# -> Int#
+ltWord8# a1 a2 = (GHC.Prim.ltWord8#) a1 a2
+{-# NOINLINE neWord8# #-}
+neWord8# :: Word8# -> Word8# -> Int#
+neWord8# a1 a2 = (GHC.Prim.neWord8#) a1 a2
+{-# NOINLINE extendInt16# #-}
+extendInt16# :: Int16# -> Int#
+extendInt16# a1 = (GHC.Prim.extendInt16#) a1
+{-# NOINLINE narrowInt16# #-}
+narrowInt16# :: Int# -> Int16#
+narrowInt16# a1 = (GHC.Prim.narrowInt16#) a1
+{-# NOINLINE negateInt16# #-}
+negateInt16# :: Int16# -> Int16#
+negateInt16# a1 = (GHC.Prim.negateInt16#) a1
+{-# NOINLINE plusInt16# #-}
+plusInt16# :: Int16# -> Int16# -> Int16#
+plusInt16# a1 a2 = (GHC.Prim.plusInt16#) a1 a2
+{-# NOINLINE subInt16# #-}
+subInt16# :: Int16# -> Int16# -> Int16#
+subInt16# a1 a2 = (GHC.Prim.subInt16#) a1 a2
+{-# NOINLINE timesInt16# #-}
+timesInt16# :: Int16# -> Int16# -> Int16#
+timesInt16# a1 a2 = (GHC.Prim.timesInt16#) a1 a2
+{-# NOINLINE quotInt16# #-}
+quotInt16# :: Int16# -> Int16# -> Int16#
+quotInt16# a1 a2 = (GHC.Prim.quotInt16#) a1 a2
+{-# NOINLINE remInt16# #-}
+remInt16# :: Int16# -> Int16# -> Int16#
+remInt16# a1 a2 = (GHC.Prim.remInt16#) a1 a2
+{-# NOINLINE quotRemInt16# #-}
+quotRemInt16# :: Int16# -> Int16# -> (# Int16#,Int16# #)
+quotRemInt16# a1 a2 = (GHC.Prim.quotRemInt16#) a1 a2
+{-# NOINLINE eqInt16# #-}
+eqInt16# :: Int16# -> Int16# -> Int#
+eqInt16# a1 a2 = (GHC.Prim.eqInt16#) a1 a2
+{-# NOINLINE geInt16# #-}
+geInt16# :: Int16# -> Int16# -> Int#
+geInt16# a1 a2 = (GHC.Prim.geInt16#) a1 a2
+{-# NOINLINE gtInt16# #-}
+gtInt16# :: Int16# -> Int16# -> Int#
+gtInt16# a1 a2 = (GHC.Prim.gtInt16#) a1 a2
+{-# NOINLINE leInt16# #-}
+leInt16# :: Int16# -> Int16# -> Int#
+leInt16# a1 a2 = (GHC.Prim.leInt16#) a1 a2
+{-# NOINLINE ltInt16# #-}
+ltInt16# :: Int16# -> Int16# -> Int#
+ltInt16# a1 a2 = (GHC.Prim.ltInt16#) a1 a2
+{-# NOINLINE neInt16# #-}
+neInt16# :: Int16# -> Int16# -> Int#
+neInt16# a1 a2 = (GHC.Prim.neInt16#) a1 a2
+{-# NOINLINE extendWord16# #-}
+extendWord16# :: Word16# -> Word#
+extendWord16# a1 = (GHC.Prim.extendWord16#) a1
+{-# NOINLINE narrowWord16# #-}
+narrowWord16# :: Word# -> Word16#
+narrowWord16# a1 = (GHC.Prim.narrowWord16#) a1
+{-# NOINLINE notWord16# #-}
+notWord16# :: Word16# -> Word16#
+notWord16# a1 = (GHC.Prim.notWord16#) a1
+{-# NOINLINE plusWord16# #-}
+plusWord16# :: Word16# -> Word16# -> Word16#
+plusWord16# a1 a2 = (GHC.Prim.plusWord16#) a1 a2
+{-# NOINLINE subWord16# #-}
+subWord16# :: Word16# -> Word16# -> Word16#
+subWord16# a1 a2 = (GHC.Prim.subWord16#) a1 a2
+{-# NOINLINE timesWord16# #-}
+timesWord16# :: Word16# -> Word16# -> Word16#
+timesWord16# a1 a2 = (GHC.Prim.timesWord16#) a1 a2
+{-# NOINLINE quotWord16# #-}
+quotWord16# :: Word16# -> Word16# -> Word16#
+quotWord16# a1 a2 = (GHC.Prim.quotWord16#) a1 a2
+{-# NOINLINE remWord16# #-}
+remWord16# :: Word16# -> Word16# -> Word16#
+remWord16# a1 a2 = (GHC.Prim.remWord16#) a1 a2
+{-# NOINLINE quotRemWord16# #-}
+quotRemWord16# :: Word16# -> Word16# -> (# Word16#,Word16# #)
+quotRemWord16# a1 a2 = (GHC.Prim.quotRemWord16#) a1 a2
+{-# NOINLINE eqWord16# #-}
+eqWord16# :: Word16# -> Word16# -> Int#
+eqWord16# a1 a2 = (GHC.Prim.eqWord16#) a1 a2
+{-# NOINLINE geWord16# #-}
+geWord16# :: Word16# -> Word16# -> Int#
+geWord16# a1 a2 = (GHC.Prim.geWord16#) a1 a2
+{-# NOINLINE gtWord16# #-}
+gtWord16# :: Word16# -> Word16# -> Int#
+gtWord16# a1 a2 = (GHC.Prim.gtWord16#) a1 a2
+{-# NOINLINE leWord16# #-}
+leWord16# :: Word16# -> Word16# -> Int#
+leWord16# a1 a2 = (GHC.Prim.leWord16#) a1 a2
+{-# NOINLINE ltWord16# #-}
+ltWord16# :: Word16# -> Word16# -> Int#
+ltWord16# a1 a2 = (GHC.Prim.ltWord16#) a1 a2
+{-# NOINLINE neWord16# #-}
+neWord16# :: Word16# -> Word16# -> Int#
+neWord16# a1 a2 = (GHC.Prim.neWord16#) a1 a2
+{-# NOINLINE plusWord# #-}
+plusWord# :: Word# -> Word# -> Word#
+plusWord# a1 a2 = (GHC.Prim.plusWord#) a1 a2
+{-# NOINLINE addWordC# #-}
+addWordC# :: Word# -> Word# -> (# Word#,Int# #)
+addWordC# a1 a2 = (GHC.Prim.addWordC#) a1 a2
+{-# NOINLINE subWordC# #-}
+subWordC# :: Word# -> Word# -> (# Word#,Int# #)
+subWordC# a1 a2 = (GHC.Prim.subWordC#) a1 a2
+{-# NOINLINE plusWord2# #-}
+plusWord2# :: Word# -> Word# -> (# Word#,Word# #)
+plusWord2# a1 a2 = (GHC.Prim.plusWord2#) a1 a2
+{-# NOINLINE minusWord# #-}
+minusWord# :: Word# -> Word# -> Word#
+minusWord# a1 a2 = (GHC.Prim.minusWord#) a1 a2
+{-# NOINLINE timesWord# #-}
+timesWord# :: Word# -> Word# -> Word#
+timesWord# a1 a2 = (GHC.Prim.timesWord#) a1 a2
+{-# NOINLINE timesWord2# #-}
+timesWord2# :: Word# -> Word# -> (# Word#,Word# #)
+timesWord2# a1 a2 = (GHC.Prim.timesWord2#) a1 a2
+{-# NOINLINE quotWord# #-}
+quotWord# :: Word# -> Word# -> Word#
+quotWord# a1 a2 = (GHC.Prim.quotWord#) a1 a2
+{-# NOINLINE remWord# #-}
+remWord# :: Word# -> Word# -> Word#
+remWord# a1 a2 = (GHC.Prim.remWord#) a1 a2
+{-# NOINLINE quotRemWord# #-}
+quotRemWord# :: Word# -> Word# -> (# Word#,Word# #)
+quotRemWord# a1 a2 = (GHC.Prim.quotRemWord#) a1 a2
+{-# NOINLINE quotRemWord2# #-}
+quotRemWord2# :: Word# -> Word# -> Word# -> (# Word#,Word# #)
+quotRemWord2# a1 a2 a3 = (GHC.Prim.quotRemWord2#) a1 a2 a3
+{-# NOINLINE and# #-}
+and# :: Word# -> Word# -> Word#
+and# a1 a2 = (GHC.Prim.and#) a1 a2
+{-# NOINLINE or# #-}
+or# :: Word# -> Word# -> Word#
+or# a1 a2 = (GHC.Prim.or#) a1 a2
+{-# NOINLINE xor# #-}
+xor# :: Word# -> Word# -> Word#
+xor# a1 a2 = (GHC.Prim.xor#) a1 a2
+{-# NOINLINE not# #-}
+not# :: Word# -> Word#
+not# a1 = (GHC.Prim.not#) a1
+{-# NOINLINE uncheckedShiftL# #-}
+uncheckedShiftL# :: Word# -> Int# -> Word#
+uncheckedShiftL# a1 a2 = (GHC.Prim.uncheckedShiftL#) a1 a2
+{-# NOINLINE uncheckedShiftRL# #-}
+uncheckedShiftRL# :: Word# -> Int# -> Word#
+uncheckedShiftRL# a1 a2 = (GHC.Prim.uncheckedShiftRL#) a1 a2
+{-# NOINLINE word2Int# #-}
+word2Int# :: Word# -> Int#
+word2Int# a1 = (GHC.Prim.word2Int#) a1
+{-# NOINLINE gtWord# #-}
+gtWord# :: Word# -> Word# -> Int#
+gtWord# a1 a2 = (GHC.Prim.gtWord#) a1 a2
+{-# NOINLINE geWord# #-}
+geWord# :: Word# -> Word# -> Int#
+geWord# a1 a2 = (GHC.Prim.geWord#) a1 a2
+{-# NOINLINE eqWord# #-}
+eqWord# :: Word# -> Word# -> Int#
+eqWord# a1 a2 = (GHC.Prim.eqWord#) a1 a2
+{-# NOINLINE neWord# #-}
+neWord# :: Word# -> Word# -> Int#
+neWord# a1 a2 = (GHC.Prim.neWord#) a1 a2
+{-# NOINLINE ltWord# #-}
+ltWord# :: Word# -> Word# -> Int#
+ltWord# a1 a2 = (GHC.Prim.ltWord#) a1 a2
+{-# NOINLINE leWord# #-}
+leWord# :: Word# -> Word# -> Int#
+leWord# a1 a2 = (GHC.Prim.leWord#) a1 a2
+{-# NOINLINE popCnt8# #-}
+popCnt8# :: Word# -> Word#
+popCnt8# a1 = (GHC.Prim.popCnt8#) a1
+{-# NOINLINE popCnt16# #-}
+popCnt16# :: Word# -> Word#
+popCnt16# a1 = (GHC.Prim.popCnt16#) a1
+{-# NOINLINE popCnt32# #-}
+popCnt32# :: Word# -> Word#
+popCnt32# a1 = (GHC.Prim.popCnt32#) a1
+{-# NOINLINE popCnt64# #-}
+popCnt64# :: Word# -> Word#
+popCnt64# a1 = (GHC.Prim.popCnt64#) a1
+{-# NOINLINE popCnt# #-}
+popCnt# :: Word# -> Word#
+popCnt# a1 = (GHC.Prim.popCnt#) a1
+{-# NOINLINE pdep8# #-}
+pdep8# :: Word# -> Word# -> Word#
+pdep8# a1 a2 = (GHC.Prim.pdep8#) a1 a2
+{-# NOINLINE pdep16# #-}
+pdep16# :: Word# -> Word# -> Word#
+pdep16# a1 a2 = (GHC.Prim.pdep16#) a1 a2
+{-# NOINLINE pdep32# #-}
+pdep32# :: Word# -> Word# -> Word#
+pdep32# a1 a2 = (GHC.Prim.pdep32#) a1 a2
+{-# NOINLINE pdep64# #-}
+pdep64# :: Word# -> Word# -> Word#
+pdep64# a1 a2 = (GHC.Prim.pdep64#) a1 a2
+{-# NOINLINE pdep# #-}
+pdep# :: Word# -> Word# -> Word#
+pdep# a1 a2 = (GHC.Prim.pdep#) a1 a2
+{-# NOINLINE pext8# #-}
+pext8# :: Word# -> Word# -> Word#
+pext8# a1 a2 = (GHC.Prim.pext8#) a1 a2
+{-# NOINLINE pext16# #-}
+pext16# :: Word# -> Word# -> Word#
+pext16# a1 a2 = (GHC.Prim.pext16#) a1 a2
+{-# NOINLINE pext32# #-}
+pext32# :: Word# -> Word# -> Word#
+pext32# a1 a2 = (GHC.Prim.pext32#) a1 a2
+{-# NOINLINE pext64# #-}
+pext64# :: Word# -> Word# -> Word#
+pext64# a1 a2 = (GHC.Prim.pext64#) a1 a2
+{-# NOINLINE pext# #-}
+pext# :: Word# -> Word# -> Word#
+pext# a1 a2 = (GHC.Prim.pext#) a1 a2
+{-# NOINLINE clz8# #-}
+clz8# :: Word# -> Word#
+clz8# a1 = (GHC.Prim.clz8#) a1
+{-# NOINLINE clz16# #-}
+clz16# :: Word# -> Word#
+clz16# a1 = (GHC.Prim.clz16#) a1
+{-# NOINLINE clz32# #-}
+clz32# :: Word# -> Word#
+clz32# a1 = (GHC.Prim.clz32#) a1
+{-# NOINLINE clz64# #-}
+clz64# :: Word# -> Word#
+clz64# a1 = (GHC.Prim.clz64#) a1
+{-# NOINLINE clz# #-}
+clz# :: Word# -> Word#
+clz# a1 = (GHC.Prim.clz#) a1
+{-# NOINLINE ctz8# #-}
+ctz8# :: Word# -> Word#
+ctz8# a1 = (GHC.Prim.ctz8#) a1
+{-# NOINLINE ctz16# #-}
+ctz16# :: Word# -> Word#
+ctz16# a1 = (GHC.Prim.ctz16#) a1
+{-# NOINLINE ctz32# #-}
+ctz32# :: Word# -> Word#
+ctz32# a1 = (GHC.Prim.ctz32#) a1
+{-# NOINLINE ctz64# #-}
+ctz64# :: Word# -> Word#
+ctz64# a1 = (GHC.Prim.ctz64#) a1
+{-# NOINLINE ctz# #-}
+ctz# :: Word# -> Word#
+ctz# a1 = (GHC.Prim.ctz#) a1
+{-# NOINLINE byteSwap16# #-}
+byteSwap16# :: Word# -> Word#
+byteSwap16# a1 = (GHC.Prim.byteSwap16#) a1
+{-# NOINLINE byteSwap32# #-}
+byteSwap32# :: Word# -> Word#
+byteSwap32# a1 = (GHC.Prim.byteSwap32#) a1
+{-# NOINLINE byteSwap64# #-}
+byteSwap64# :: Word# -> Word#
+byteSwap64# a1 = (GHC.Prim.byteSwap64#) a1
+{-# NOINLINE byteSwap# #-}
+byteSwap# :: Word# -> Word#
+byteSwap# a1 = (GHC.Prim.byteSwap#) a1
+{-# NOINLINE bitReverse8# #-}
+bitReverse8# :: Word# -> Word#
+bitReverse8# a1 = (GHC.Prim.bitReverse8#) a1
+{-# NOINLINE bitReverse16# #-}
+bitReverse16# :: Word# -> Word#
+bitReverse16# a1 = (GHC.Prim.bitReverse16#) a1
+{-# NOINLINE bitReverse32# #-}
+bitReverse32# :: Word# -> Word#
+bitReverse32# a1 = (GHC.Prim.bitReverse32#) a1
+{-# NOINLINE bitReverse64# #-}
+bitReverse64# :: Word# -> Word#
+bitReverse64# a1 = (GHC.Prim.bitReverse64#) a1
+{-# NOINLINE bitReverse# #-}
+bitReverse# :: Word# -> Word#
+bitReverse# a1 = (GHC.Prim.bitReverse#) a1
+{-# NOINLINE narrow8Int# #-}
+narrow8Int# :: Int# -> Int#
+narrow8Int# a1 = (GHC.Prim.narrow8Int#) a1
+{-# NOINLINE narrow16Int# #-}
+narrow16Int# :: Int# -> Int#
+narrow16Int# a1 = (GHC.Prim.narrow16Int#) a1
+{-# NOINLINE narrow32Int# #-}
+narrow32Int# :: Int# -> Int#
+narrow32Int# a1 = (GHC.Prim.narrow32Int#) a1
+{-# NOINLINE narrow8Word# #-}
+narrow8Word# :: Word# -> Word#
+narrow8Word# a1 = (GHC.Prim.narrow8Word#) a1
+{-# NOINLINE narrow16Word# #-}
+narrow16Word# :: Word# -> Word#
+narrow16Word# a1 = (GHC.Prim.narrow16Word#) a1
+{-# NOINLINE narrow32Word# #-}
+narrow32Word# :: Word# -> Word#
+narrow32Word# a1 = (GHC.Prim.narrow32Word#) a1
+{-# NOINLINE (>##) #-}
+(>##) :: Double# -> Double# -> Int#
+(>##) a1 a2 = (GHC.Prim.>##) a1 a2
+{-# NOINLINE (>=##) #-}
+(>=##) :: Double# -> Double# -> Int#
+(>=##) a1 a2 = (GHC.Prim.>=##) a1 a2
+{-# NOINLINE (==##) #-}
+(==##) :: Double# -> Double# -> Int#
+(==##) a1 a2 = (GHC.Prim.==##) a1 a2
+{-# NOINLINE (/=##) #-}
+(/=##) :: Double# -> Double# -> Int#
+(/=##) a1 a2 = (GHC.Prim./=##) a1 a2
+{-# NOINLINE (<##) #-}
+(<##) :: Double# -> Double# -> Int#
+(<##) a1 a2 = (GHC.Prim.<##) a1 a2
+{-# NOINLINE (<=##) #-}
+(<=##) :: Double# -> Double# -> Int#
+(<=##) a1 a2 = (GHC.Prim.<=##) a1 a2
+{-# NOINLINE (+##) #-}
+(+##) :: Double# -> Double# -> Double#
+(+##) a1 a2 = (GHC.Prim.+##) a1 a2
+{-# NOINLINE (-##) #-}
+(-##) :: Double# -> Double# -> Double#
+(-##) a1 a2 = (GHC.Prim.-##) a1 a2
+{-# NOINLINE (*##) #-}
+(*##) :: Double# -> Double# -> Double#
+(*##) a1 a2 = (GHC.Prim.*##) a1 a2
+{-# NOINLINE (/##) #-}
+(/##) :: Double# -> Double# -> Double#
+(/##) a1 a2 = (GHC.Prim./##) a1 a2
+{-# NOINLINE negateDouble# #-}
+negateDouble# :: Double# -> Double#
+negateDouble# a1 = (GHC.Prim.negateDouble#) a1
+{-# NOINLINE fabsDouble# #-}
+fabsDouble# :: Double# -> Double#
+fabsDouble# a1 = (GHC.Prim.fabsDouble#) a1
+{-# NOINLINE double2Int# #-}
+double2Int# :: Double# -> Int#
+double2Int# a1 = (GHC.Prim.double2Int#) a1
+{-# NOINLINE double2Float# #-}
+double2Float# :: Double# -> Float#
+double2Float# a1 = (GHC.Prim.double2Float#) a1
+{-# NOINLINE expDouble# #-}
+expDouble# :: Double# -> Double#
+expDouble# a1 = (GHC.Prim.expDouble#) a1
+{-# NOINLINE logDouble# #-}
+logDouble# :: Double# -> Double#
+logDouble# a1 = (GHC.Prim.logDouble#) a1
+{-# NOINLINE sqrtDouble# #-}
+sqrtDouble# :: Double# -> Double#
+sqrtDouble# a1 = (GHC.Prim.sqrtDouble#) a1
+{-# NOINLINE sinDouble# #-}
+sinDouble# :: Double# -> Double#
+sinDouble# a1 = (GHC.Prim.sinDouble#) a1
+{-# NOINLINE cosDouble# #-}
+cosDouble# :: Double# -> Double#
+cosDouble# a1 = (GHC.Prim.cosDouble#) a1
+{-# NOINLINE tanDouble# #-}
+tanDouble# :: Double# -> Double#
+tanDouble# a1 = (GHC.Prim.tanDouble#) a1
+{-# NOINLINE asinDouble# #-}
+asinDouble# :: Double# -> Double#
+asinDouble# a1 = (GHC.Prim.asinDouble#) a1
+{-# NOINLINE acosDouble# #-}
+acosDouble# :: Double# -> Double#
+acosDouble# a1 = (GHC.Prim.acosDouble#) a1
+{-# NOINLINE atanDouble# #-}
+atanDouble# :: Double# -> Double#
+atanDouble# a1 = (GHC.Prim.atanDouble#) a1
+{-# NOINLINE sinhDouble# #-}
+sinhDouble# :: Double# -> Double#
+sinhDouble# a1 = (GHC.Prim.sinhDouble#) a1
+{-# NOINLINE coshDouble# #-}
+coshDouble# :: Double# -> Double#
+coshDouble# a1 = (GHC.Prim.coshDouble#) a1
+{-# NOINLINE tanhDouble# #-}
+tanhDouble# :: Double# -> Double#
+tanhDouble# a1 = (GHC.Prim.tanhDouble#) a1
+{-# NOINLINE asinhDouble# #-}
+asinhDouble# :: Double# -> Double#
+asinhDouble# a1 = (GHC.Prim.asinhDouble#) a1
+{-# NOINLINE acoshDouble# #-}
+acoshDouble# :: Double# -> Double#
+acoshDouble# a1 = (GHC.Prim.acoshDouble#) a1
+{-# NOINLINE atanhDouble# #-}
+atanhDouble# :: Double# -> Double#
+atanhDouble# a1 = (GHC.Prim.atanhDouble#) a1
+{-# NOINLINE (**##) #-}
+(**##) :: Double# -> Double# -> Double#
+(**##) a1 a2 = (GHC.Prim.**##) a1 a2
+{-# NOINLINE decodeDouble_2Int# #-}
+decodeDouble_2Int# :: Double# -> (# Int#,Word#,Word#,Int# #)
+decodeDouble_2Int# a1 = (GHC.Prim.decodeDouble_2Int#) a1
+{-# NOINLINE decodeDouble_Int64# #-}
+decodeDouble_Int64# :: Double# -> (# Int#,Int# #)
+decodeDouble_Int64# a1 = (GHC.Prim.decodeDouble_Int64#) a1
+{-# NOINLINE gtFloat# #-}
+gtFloat# :: Float# -> Float# -> Int#
+gtFloat# a1 a2 = (GHC.Prim.gtFloat#) a1 a2
+{-# NOINLINE geFloat# #-}
+geFloat# :: Float# -> Float# -> Int#
+geFloat# a1 a2 = (GHC.Prim.geFloat#) a1 a2
+{-# NOINLINE eqFloat# #-}
+eqFloat# :: Float# -> Float# -> Int#
+eqFloat# a1 a2 = (GHC.Prim.eqFloat#) a1 a2
+{-# NOINLINE neFloat# #-}
+neFloat# :: Float# -> Float# -> Int#
+neFloat# a1 a2 = (GHC.Prim.neFloat#) a1 a2
+{-# NOINLINE ltFloat# #-}
+ltFloat# :: Float# -> Float# -> Int#
+ltFloat# a1 a2 = (GHC.Prim.ltFloat#) a1 a2
+{-# NOINLINE leFloat# #-}
+leFloat# :: Float# -> Float# -> Int#
+leFloat# a1 a2 = (GHC.Prim.leFloat#) a1 a2
+{-# NOINLINE plusFloat# #-}
+plusFloat# :: Float# -> Float# -> Float#
+plusFloat# a1 a2 = (GHC.Prim.plusFloat#) a1 a2
+{-# NOINLINE minusFloat# #-}
+minusFloat# :: Float# -> Float# -> Float#
+minusFloat# a1 a2 = (GHC.Prim.minusFloat#) a1 a2
+{-# NOINLINE timesFloat# #-}
+timesFloat# :: Float# -> Float# -> Float#
+timesFloat# a1 a2 = (GHC.Prim.timesFloat#) a1 a2
+{-# NOINLINE divideFloat# #-}
+divideFloat# :: Float# -> Float# -> Float#
+divideFloat# a1 a2 = (GHC.Prim.divideFloat#) a1 a2
+{-# NOINLINE negateFloat# #-}
+negateFloat# :: Float# -> Float#
+negateFloat# a1 = (GHC.Prim.negateFloat#) a1
+{-# NOINLINE fabsFloat# #-}
+fabsFloat# :: Float# -> Float#
+fabsFloat# a1 = (GHC.Prim.fabsFloat#) a1
+{-# NOINLINE float2Int# #-}
+float2Int# :: Float# -> Int#
+float2Int# a1 = (GHC.Prim.float2Int#) a1
+{-# NOINLINE expFloat# #-}
+expFloat# :: Float# -> Float#
+expFloat# a1 = (GHC.Prim.expFloat#) a1
+{-# NOINLINE logFloat# #-}
+logFloat# :: Float# -> Float#
+logFloat# a1 = (GHC.Prim.logFloat#) a1
+{-# NOINLINE sqrtFloat# #-}
+sqrtFloat# :: Float# -> Float#
+sqrtFloat# a1 = (GHC.Prim.sqrtFloat#) a1
+{-# NOINLINE sinFloat# #-}
+sinFloat# :: Float# -> Float#
+sinFloat# a1 = (GHC.Prim.sinFloat#) a1
+{-# NOINLINE cosFloat# #-}
+cosFloat# :: Float# -> Float#
+cosFloat# a1 = (GHC.Prim.cosFloat#) a1
+{-# NOINLINE tanFloat# #-}
+tanFloat# :: Float# -> Float#
+tanFloat# a1 = (GHC.Prim.tanFloat#) a1
+{-# NOINLINE asinFloat# #-}
+asinFloat# :: Float# -> Float#
+asinFloat# a1 = (GHC.Prim.asinFloat#) a1
+{-# NOINLINE acosFloat# #-}
+acosFloat# :: Float# -> Float#
+acosFloat# a1 = (GHC.Prim.acosFloat#) a1
+{-# NOINLINE atanFloat# #-}
+atanFloat# :: Float# -> Float#
+atanFloat# a1 = (GHC.Prim.atanFloat#) a1
+{-# NOINLINE sinhFloat# #-}
+sinhFloat# :: Float# -> Float#
+sinhFloat# a1 = (GHC.Prim.sinhFloat#) a1
+{-# NOINLINE coshFloat# #-}
+coshFloat# :: Float# -> Float#
+coshFloat# a1 = (GHC.Prim.coshFloat#) a1
+{-# NOINLINE tanhFloat# #-}
+tanhFloat# :: Float# -> Float#
+tanhFloat# a1 = (GHC.Prim.tanhFloat#) a1
+{-# NOINLINE asinhFloat# #-}
+asinhFloat# :: Float# -> Float#
+asinhFloat# a1 = (GHC.Prim.asinhFloat#) a1
+{-# NOINLINE acoshFloat# #-}
+acoshFloat# :: Float# -> Float#
+acoshFloat# a1 = (GHC.Prim.acoshFloat#) a1
+{-# NOINLINE atanhFloat# #-}
+atanhFloat# :: Float# -> Float#
+atanhFloat# a1 = (GHC.Prim.atanhFloat#) a1
+{-# NOINLINE powerFloat# #-}
+powerFloat# :: Float# -> Float# -> Float#
+powerFloat# a1 a2 = (GHC.Prim.powerFloat#) a1 a2
+{-# NOINLINE float2Double# #-}
+float2Double# :: Float# -> Double#
+float2Double# a1 = (GHC.Prim.float2Double#) a1
+{-# NOINLINE decodeFloat_Int# #-}
+decodeFloat_Int# :: Float# -> (# Int#,Int# #)
+decodeFloat_Int# a1 = (GHC.Prim.decodeFloat_Int#) a1
+{-# NOINLINE newArray# #-}
+newArray# :: Int# -> a -> State# s -> (# State# s,MutableArray# s a #)
+newArray# a1 a2 a3 = (GHC.Prim.newArray#) a1 a2 a3
+{-# NOINLINE sameMutableArray# #-}
+sameMutableArray# :: MutableArray# s a -> MutableArray# s a -> Int#
+sameMutableArray# a1 a2 = (GHC.Prim.sameMutableArray#) a1 a2
+{-# NOINLINE readArray# #-}
+readArray# :: MutableArray# s a -> Int# -> State# s -> (# State# s,a #)
+readArray# a1 a2 a3 = (GHC.Prim.readArray#) a1 a2 a3
+{-# NOINLINE writeArray# #-}
+writeArray# :: MutableArray# s a -> Int# -> a -> State# s -> State# s
+writeArray# a1 a2 a3 a4 = (GHC.Prim.writeArray#) a1 a2 a3 a4
+{-# NOINLINE sizeofArray# #-}
+sizeofArray# :: Array# a -> Int#
+sizeofArray# a1 = (GHC.Prim.sizeofArray#) a1
+{-# NOINLINE sizeofMutableArray# #-}
+sizeofMutableArray# :: MutableArray# s a -> Int#
+sizeofMutableArray# a1 = (GHC.Prim.sizeofMutableArray#) a1
+{-# NOINLINE indexArray# #-}
+indexArray# :: Array# a -> Int# -> (# a #)
+indexArray# a1 a2 = (GHC.Prim.indexArray#) a1 a2
+{-# NOINLINE unsafeFreezeArray# #-}
+unsafeFreezeArray# :: MutableArray# s a -> State# s -> (# State# s,Array# a #)
+unsafeFreezeArray# a1 a2 = (GHC.Prim.unsafeFreezeArray#) a1 a2
+{-# NOINLINE unsafeThawArray# #-}
+unsafeThawArray# :: Array# a -> State# s -> (# State# s,MutableArray# s a #)
+unsafeThawArray# a1 a2 = (GHC.Prim.unsafeThawArray#) a1 a2
+{-# NOINLINE copyArray# #-}
+copyArray# :: Array# a -> Int# -> MutableArray# s a -> Int# -> Int# -> State# s -> State# s
+copyArray# a1 a2 a3 a4 a5 a6 = (GHC.Prim.copyArray#) a1 a2 a3 a4 a5 a6
+{-# NOINLINE copyMutableArray# #-}
+copyMutableArray# :: MutableArray# s a -> Int# -> MutableArray# s a -> Int# -> Int# -> State# s -> State# s
+copyMutableArray# a1 a2 a3 a4 a5 a6 = (GHC.Prim.copyMutableArray#) a1 a2 a3 a4 a5 a6
+{-# NOINLINE cloneArray# #-}
+cloneArray# :: Array# a -> Int# -> Int# -> Array# a
+cloneArray# a1 a2 a3 = (GHC.Prim.cloneArray#) a1 a2 a3
+{-# NOINLINE cloneMutableArray# #-}
+cloneMutableArray# :: MutableArray# s a -> Int# -> Int# -> State# s -> (# State# s,MutableArray# s a #)
+cloneMutableArray# a1 a2 a3 a4 = (GHC.Prim.cloneMutableArray#) a1 a2 a3 a4
+{-# NOINLINE freezeArray# #-}
+freezeArray# :: MutableArray# s a -> Int# -> Int# -> State# s -> (# State# s,Array# a #)
+freezeArray# a1 a2 a3 a4 = (GHC.Prim.freezeArray#) a1 a2 a3 a4
+{-# NOINLINE thawArray# #-}
+thawArray# :: Array# a -> Int# -> Int# -> State# s -> (# State# s,MutableArray# s a #)
+thawArray# a1 a2 a3 a4 = (GHC.Prim.thawArray#) a1 a2 a3 a4
+{-# NOINLINE casArray# #-}
+casArray# :: MutableArray# s a -> Int# -> a -> a -> State# s -> (# State# s,Int#,a #)
+casArray# a1 a2 a3 a4 a5 = (GHC.Prim.casArray#) a1 a2 a3 a4 a5
+{-# NOINLINE newSmallArray# #-}
+newSmallArray# :: Int# -> a -> State# s -> (# State# s,SmallMutableArray# s a #)
+newSmallArray# a1 a2 a3 = (GHC.Prim.newSmallArray#) a1 a2 a3
+{-# NOINLINE sameSmallMutableArray# #-}
+sameSmallMutableArray# :: SmallMutableArray# s a -> SmallMutableArray# s a -> Int#
+sameSmallMutableArray# a1 a2 = (GHC.Prim.sameSmallMutableArray#) a1 a2
+{-# NOINLINE readSmallArray# #-}
+readSmallArray# :: SmallMutableArray# s a -> Int# -> State# s -> (# State# s,a #)
+readSmallArray# a1 a2 a3 = (GHC.Prim.readSmallArray#) a1 a2 a3
+{-# NOINLINE writeSmallArray# #-}
+writeSmallArray# :: SmallMutableArray# s a -> Int# -> a -> State# s -> State# s
+writeSmallArray# a1 a2 a3 a4 = (GHC.Prim.writeSmallArray#) a1 a2 a3 a4
+{-# NOINLINE sizeofSmallArray# #-}
+sizeofSmallArray# :: SmallArray# a -> Int#
+sizeofSmallArray# a1 = (GHC.Prim.sizeofSmallArray#) a1
+{-# NOINLINE sizeofSmallMutableArray# #-}
+sizeofSmallMutableArray# :: SmallMutableArray# s a -> Int#
+sizeofSmallMutableArray# a1 = (GHC.Prim.sizeofSmallMutableArray#) a1
+{-# NOINLINE indexSmallArray# #-}
+indexSmallArray# :: SmallArray# a -> Int# -> (# a #)
+indexSmallArray# a1 a2 = (GHC.Prim.indexSmallArray#) a1 a2
+{-# NOINLINE unsafeFreezeSmallArray# #-}
+unsafeFreezeSmallArray# :: SmallMutableArray# s a -> State# s -> (# State# s,SmallArray# a #)
+unsafeFreezeSmallArray# a1 a2 = (GHC.Prim.unsafeFreezeSmallArray#) a1 a2
+{-# NOINLINE unsafeThawSmallArray# #-}
+unsafeThawSmallArray# :: SmallArray# a -> State# s -> (# State# s,SmallMutableArray# s a #)
+unsafeThawSmallArray# a1 a2 = (GHC.Prim.unsafeThawSmallArray#) a1 a2
+{-# NOINLINE copySmallArray# #-}
+copySmallArray# :: SmallArray# a -> Int# -> SmallMutableArray# s a -> Int# -> Int# -> State# s -> State# s
+copySmallArray# a1 a2 a3 a4 a5 a6 = (GHC.Prim.copySmallArray#) a1 a2 a3 a4 a5 a6
+{-# NOINLINE copySmallMutableArray# #-}
+copySmallMutableArray# :: SmallMutableArray# s a -> Int# -> SmallMutableArray# s a -> Int# -> Int# -> State# s -> State# s
+copySmallMutableArray# a1 a2 a3 a4 a5 a6 = (GHC.Prim.copySmallMutableArray#) a1 a2 a3 a4 a5 a6
+{-# NOINLINE cloneSmallArray# #-}
+cloneSmallArray# :: SmallArray# a -> Int# -> Int# -> SmallArray# a
+cloneSmallArray# a1 a2 a3 = (GHC.Prim.cloneSmallArray#) a1 a2 a3
+{-# NOINLINE cloneSmallMutableArray# #-}
+cloneSmallMutableArray# :: SmallMutableArray# s a -> Int# -> Int# -> State# s -> (# State# s,SmallMutableArray# s a #)
+cloneSmallMutableArray# a1 a2 a3 a4 = (GHC.Prim.cloneSmallMutableArray#) a1 a2 a3 a4
+{-# NOINLINE freezeSmallArray# #-}
+freezeSmallArray# :: SmallMutableArray# s a -> Int# -> Int# -> State# s -> (# State# s,SmallArray# a #)
+freezeSmallArray# a1 a2 a3 a4 = (GHC.Prim.freezeSmallArray#) a1 a2 a3 a4
+{-# NOINLINE thawSmallArray# #-}
+thawSmallArray# :: SmallArray# a -> Int# -> Int# -> State# s -> (# State# s,SmallMutableArray# s a #)
+thawSmallArray# a1 a2 a3 a4 = (GHC.Prim.thawSmallArray#) a1 a2 a3 a4
+{-# NOINLINE casSmallArray# #-}
+casSmallArray# :: SmallMutableArray# s a -> Int# -> a -> a -> State# s -> (# State# s,Int#,a #)
+casSmallArray# a1 a2 a3 a4 a5 = (GHC.Prim.casSmallArray#) a1 a2 a3 a4 a5
+{-# NOINLINE newByteArray# #-}
+newByteArray# :: Int# -> State# s -> (# State# s,MutableByteArray# s #)
+newByteArray# a1 a2 = (GHC.Prim.newByteArray#) a1 a2
+{-# NOINLINE newPinnedByteArray# #-}
+newPinnedByteArray# :: Int# -> State# s -> (# State# s,MutableByteArray# s #)
+newPinnedByteArray# a1 a2 = (GHC.Prim.newPinnedByteArray#) a1 a2
+{-# NOINLINE newAlignedPinnedByteArray# #-}
+newAlignedPinnedByteArray# :: Int# -> Int# -> State# s -> (# State# s,MutableByteArray# s #)
+newAlignedPinnedByteArray# a1 a2 a3 = (GHC.Prim.newAlignedPinnedByteArray#) a1 a2 a3
+{-# NOINLINE isMutableByteArrayPinned# #-}
+isMutableByteArrayPinned# :: MutableByteArray# s -> Int#
+isMutableByteArrayPinned# a1 = (GHC.Prim.isMutableByteArrayPinned#) a1
+{-# NOINLINE isByteArrayPinned# #-}
+isByteArrayPinned# :: ByteArray# -> Int#
+isByteArrayPinned# a1 = (GHC.Prim.isByteArrayPinned#) a1
+{-# NOINLINE byteArrayContents# #-}
+byteArrayContents# :: ByteArray# -> Addr#
+byteArrayContents# a1 = (GHC.Prim.byteArrayContents#) a1
+{-# NOINLINE sameMutableByteArray# #-}
+sameMutableByteArray# :: MutableByteArray# s -> MutableByteArray# s -> Int#
+sameMutableByteArray# a1 a2 = (GHC.Prim.sameMutableByteArray#) a1 a2
+{-# NOINLINE shrinkMutableByteArray# #-}
+shrinkMutableByteArray# :: MutableByteArray# s -> Int# -> State# s -> State# s
+shrinkMutableByteArray# a1 a2 a3 = (GHC.Prim.shrinkMutableByteArray#) a1 a2 a3
+{-# NOINLINE resizeMutableByteArray# #-}
+resizeMutableByteArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,MutableByteArray# s #)
+resizeMutableByteArray# a1 a2 a3 = (GHC.Prim.resizeMutableByteArray#) a1 a2 a3
+{-# NOINLINE unsafeFreezeByteArray# #-}
+unsafeFreezeByteArray# :: MutableByteArray# s -> State# s -> (# State# s,ByteArray# #)
+unsafeFreezeByteArray# a1 a2 = (GHC.Prim.unsafeFreezeByteArray#) a1 a2
+{-# NOINLINE sizeofByteArray# #-}
+sizeofByteArray# :: ByteArray# -> Int#
+sizeofByteArray# a1 = (GHC.Prim.sizeofByteArray#) a1
+{-# NOINLINE sizeofMutableByteArray# #-}
+sizeofMutableByteArray# :: MutableByteArray# s -> Int#
+sizeofMutableByteArray# a1 = (GHC.Prim.sizeofMutableByteArray#) a1
+{-# NOINLINE getSizeofMutableByteArray# #-}
+getSizeofMutableByteArray# :: MutableByteArray# s -> State# s -> (# State# s,Int# #)
+getSizeofMutableByteArray# a1 a2 = (GHC.Prim.getSizeofMutableByteArray#) a1 a2
+{-# NOINLINE indexCharArray# #-}
+indexCharArray# :: ByteArray# -> Int# -> Char#
+indexCharArray# a1 a2 = (GHC.Prim.indexCharArray#) a1 a2
+{-# NOINLINE indexWideCharArray# #-}
+indexWideCharArray# :: ByteArray# -> Int# -> Char#
+indexWideCharArray# a1 a2 = (GHC.Prim.indexWideCharArray#) a1 a2
+{-# NOINLINE indexIntArray# #-}
+indexIntArray# :: ByteArray# -> Int# -> Int#
+indexIntArray# a1 a2 = (GHC.Prim.indexIntArray#) a1 a2
+{-# NOINLINE indexWordArray# #-}
+indexWordArray# :: ByteArray# -> Int# -> Word#
+indexWordArray# a1 a2 = (GHC.Prim.indexWordArray#) a1 a2
+{-# NOINLINE indexAddrArray# #-}
+indexAddrArray# :: ByteArray# -> Int# -> Addr#
+indexAddrArray# a1 a2 = (GHC.Prim.indexAddrArray#) a1 a2
+{-# NOINLINE indexFloatArray# #-}
+indexFloatArray# :: ByteArray# -> Int# -> Float#
+indexFloatArray# a1 a2 = (GHC.Prim.indexFloatArray#) a1 a2
+{-# NOINLINE indexDoubleArray# #-}
+indexDoubleArray# :: ByteArray# -> Int# -> Double#
+indexDoubleArray# a1 a2 = (GHC.Prim.indexDoubleArray#) a1 a2
+{-# NOINLINE indexStablePtrArray# #-}
+indexStablePtrArray# :: ByteArray# -> Int# -> StablePtr# a
+indexStablePtrArray# a1 a2 = (GHC.Prim.indexStablePtrArray#) a1 a2
+{-# NOINLINE indexInt8Array# #-}
+indexInt8Array# :: ByteArray# -> Int# -> Int#
+indexInt8Array# a1 a2 = (GHC.Prim.indexInt8Array#) a1 a2
+{-# NOINLINE indexInt16Array# #-}
+indexInt16Array# :: ByteArray# -> Int# -> Int#
+indexInt16Array# a1 a2 = (GHC.Prim.indexInt16Array#) a1 a2
+{-# NOINLINE indexInt32Array# #-}
+indexInt32Array# :: ByteArray# -> Int# -> Int#
+indexInt32Array# a1 a2 = (GHC.Prim.indexInt32Array#) a1 a2
+{-# NOINLINE indexInt64Array# #-}
+indexInt64Array# :: ByteArray# -> Int# -> Int#
+indexInt64Array# a1 a2 = (GHC.Prim.indexInt64Array#) a1 a2
+{-# NOINLINE indexWord8Array# #-}
+indexWord8Array# :: ByteArray# -> Int# -> Word#
+indexWord8Array# a1 a2 = (GHC.Prim.indexWord8Array#) a1 a2
+{-# NOINLINE indexWord16Array# #-}
+indexWord16Array# :: ByteArray# -> Int# -> Word#
+indexWord16Array# a1 a2 = (GHC.Prim.indexWord16Array#) a1 a2
+{-# NOINLINE indexWord32Array# #-}
+indexWord32Array# :: ByteArray# -> Int# -> Word#
+indexWord32Array# a1 a2 = (GHC.Prim.indexWord32Array#) a1 a2
+{-# NOINLINE indexWord64Array# #-}
+indexWord64Array# :: ByteArray# -> Int# -> Word#
+indexWord64Array# a1 a2 = (GHC.Prim.indexWord64Array#) a1 a2
+{-# NOINLINE indexWord8ArrayAsChar# #-}
+indexWord8ArrayAsChar# :: ByteArray# -> Int# -> Char#
+indexWord8ArrayAsChar# a1 a2 = (GHC.Prim.indexWord8ArrayAsChar#) a1 a2
+{-# NOINLINE indexWord8ArrayAsWideChar# #-}
+indexWord8ArrayAsWideChar# :: ByteArray# -> Int# -> Char#
+indexWord8ArrayAsWideChar# a1 a2 = (GHC.Prim.indexWord8ArrayAsWideChar#) a1 a2
+{-# NOINLINE indexWord8ArrayAsAddr# #-}
+indexWord8ArrayAsAddr# :: ByteArray# -> Int# -> Addr#
+indexWord8ArrayAsAddr# a1 a2 = (GHC.Prim.indexWord8ArrayAsAddr#) a1 a2
+{-# NOINLINE indexWord8ArrayAsFloat# #-}
+indexWord8ArrayAsFloat# :: ByteArray# -> Int# -> Float#
+indexWord8ArrayAsFloat# a1 a2 = (GHC.Prim.indexWord8ArrayAsFloat#) a1 a2
+{-# NOINLINE indexWord8ArrayAsDouble# #-}
+indexWord8ArrayAsDouble# :: ByteArray# -> Int# -> Double#
+indexWord8ArrayAsDouble# a1 a2 = (GHC.Prim.indexWord8ArrayAsDouble#) a1 a2
+{-# NOINLINE indexWord8ArrayAsStablePtr# #-}
+indexWord8ArrayAsStablePtr# :: ByteArray# -> Int# -> StablePtr# a
+indexWord8ArrayAsStablePtr# a1 a2 = (GHC.Prim.indexWord8ArrayAsStablePtr#) a1 a2
+{-# NOINLINE indexWord8ArrayAsInt16# #-}
+indexWord8ArrayAsInt16# :: ByteArray# -> Int# -> Int#
+indexWord8ArrayAsInt16# a1 a2 = (GHC.Prim.indexWord8ArrayAsInt16#) a1 a2
+{-# NOINLINE indexWord8ArrayAsInt32# #-}
+indexWord8ArrayAsInt32# :: ByteArray# -> Int# -> Int#
+indexWord8ArrayAsInt32# a1 a2 = (GHC.Prim.indexWord8ArrayAsInt32#) a1 a2
+{-# NOINLINE indexWord8ArrayAsInt64# #-}
+indexWord8ArrayAsInt64# :: ByteArray# -> Int# -> Int#
+indexWord8ArrayAsInt64# a1 a2 = (GHC.Prim.indexWord8ArrayAsInt64#) a1 a2
+{-# NOINLINE indexWord8ArrayAsInt# #-}
+indexWord8ArrayAsInt# :: ByteArray# -> Int# -> Int#
+indexWord8ArrayAsInt# a1 a2 = (GHC.Prim.indexWord8ArrayAsInt#) a1 a2
+{-# NOINLINE indexWord8ArrayAsWord16# #-}
+indexWord8ArrayAsWord16# :: ByteArray# -> Int# -> Word#
+indexWord8ArrayAsWord16# a1 a2 = (GHC.Prim.indexWord8ArrayAsWord16#) a1 a2
+{-# NOINLINE indexWord8ArrayAsWord32# #-}
+indexWord8ArrayAsWord32# :: ByteArray# -> Int# -> Word#
+indexWord8ArrayAsWord32# a1 a2 = (GHC.Prim.indexWord8ArrayAsWord32#) a1 a2
+{-# NOINLINE indexWord8ArrayAsWord64# #-}
+indexWord8ArrayAsWord64# :: ByteArray# -> Int# -> Word#
+indexWord8ArrayAsWord64# a1 a2 = (GHC.Prim.indexWord8ArrayAsWord64#) a1 a2
+{-# NOINLINE indexWord8ArrayAsWord# #-}
+indexWord8ArrayAsWord# :: ByteArray# -> Int# -> Word#
+indexWord8ArrayAsWord# a1 a2 = (GHC.Prim.indexWord8ArrayAsWord#) a1 a2
+{-# NOINLINE readCharArray# #-}
+readCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Char# #)
+readCharArray# a1 a2 a3 = (GHC.Prim.readCharArray#) a1 a2 a3
+{-# NOINLINE readWideCharArray# #-}
+readWideCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Char# #)
+readWideCharArray# a1 a2 a3 = (GHC.Prim.readWideCharArray#) a1 a2 a3
+{-# NOINLINE readIntArray# #-}
+readIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int# #)
+readIntArray# a1 a2 a3 = (GHC.Prim.readIntArray#) a1 a2 a3
+{-# NOINLINE readWordArray# #-}
+readWordArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word# #)
+readWordArray# a1 a2 a3 = (GHC.Prim.readWordArray#) a1 a2 a3
+{-# NOINLINE readAddrArray# #-}
+readAddrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Addr# #)
+readAddrArray# a1 a2 a3 = (GHC.Prim.readAddrArray#) a1 a2 a3
+{-# NOINLINE readFloatArray# #-}
+readFloatArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Float# #)
+readFloatArray# a1 a2 a3 = (GHC.Prim.readFloatArray#) a1 a2 a3
+{-# NOINLINE readDoubleArray# #-}
+readDoubleArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Double# #)
+readDoubleArray# a1 a2 a3 = (GHC.Prim.readDoubleArray#) a1 a2 a3
+{-# NOINLINE readStablePtrArray# #-}
+readStablePtrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,StablePtr# a #)
+readStablePtrArray# a1 a2 a3 = (GHC.Prim.readStablePtrArray#) a1 a2 a3
+{-# NOINLINE readInt8Array# #-}
+readInt8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int# #)
+readInt8Array# a1 a2 a3 = (GHC.Prim.readInt8Array#) a1 a2 a3
+{-# NOINLINE readInt16Array# #-}
+readInt16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int# #)
+readInt16Array# a1 a2 a3 = (GHC.Prim.readInt16Array#) a1 a2 a3
+{-# NOINLINE readInt32Array# #-}
+readInt32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int# #)
+readInt32Array# a1 a2 a3 = (GHC.Prim.readInt32Array#) a1 a2 a3
+{-# NOINLINE readInt64Array# #-}
+readInt64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int# #)
+readInt64Array# a1 a2 a3 = (GHC.Prim.readInt64Array#) a1 a2 a3
+{-# NOINLINE readWord8Array# #-}
+readWord8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word# #)
+readWord8Array# a1 a2 a3 = (GHC.Prim.readWord8Array#) a1 a2 a3
+{-# NOINLINE readWord16Array# #-}
+readWord16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word# #)
+readWord16Array# a1 a2 a3 = (GHC.Prim.readWord16Array#) a1 a2 a3
+{-# NOINLINE readWord32Array# #-}
+readWord32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word# #)
+readWord32Array# a1 a2 a3 = (GHC.Prim.readWord32Array#) a1 a2 a3
+{-# NOINLINE readWord64Array# #-}
+readWord64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word# #)
+readWord64Array# a1 a2 a3 = (GHC.Prim.readWord64Array#) a1 a2 a3
+{-# NOINLINE readWord8ArrayAsChar# #-}
+readWord8ArrayAsChar# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Char# #)
+readWord8ArrayAsChar# a1 a2 a3 = (GHC.Prim.readWord8ArrayAsChar#) a1 a2 a3
+{-# NOINLINE readWord8ArrayAsWideChar# #-}
+readWord8ArrayAsWideChar# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Char# #)
+readWord8ArrayAsWideChar# a1 a2 a3 = (GHC.Prim.readWord8ArrayAsWideChar#) a1 a2 a3
+{-# NOINLINE readWord8ArrayAsAddr# #-}
+readWord8ArrayAsAddr# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Addr# #)
+readWord8ArrayAsAddr# a1 a2 a3 = (GHC.Prim.readWord8ArrayAsAddr#) a1 a2 a3
+{-# NOINLINE readWord8ArrayAsFloat# #-}
+readWord8ArrayAsFloat# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Float# #)
+readWord8ArrayAsFloat# a1 a2 a3 = (GHC.Prim.readWord8ArrayAsFloat#) a1 a2 a3
+{-# NOINLINE readWord8ArrayAsDouble# #-}
+readWord8ArrayAsDouble# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Double# #)
+readWord8ArrayAsDouble# a1 a2 a3 = (GHC.Prim.readWord8ArrayAsDouble#) a1 a2 a3
+{-# NOINLINE readWord8ArrayAsStablePtr# #-}
+readWord8ArrayAsStablePtr# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,StablePtr# a #)
+readWord8ArrayAsStablePtr# a1 a2 a3 = (GHC.Prim.readWord8ArrayAsStablePtr#) a1 a2 a3
+{-# NOINLINE readWord8ArrayAsInt16# #-}
+readWord8ArrayAsInt16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int# #)
+readWord8ArrayAsInt16# a1 a2 a3 = (GHC.Prim.readWord8ArrayAsInt16#) a1 a2 a3
+{-# NOINLINE readWord8ArrayAsInt32# #-}
+readWord8ArrayAsInt32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int# #)
+readWord8ArrayAsInt32# a1 a2 a3 = (GHC.Prim.readWord8ArrayAsInt32#) a1 a2 a3
+{-# NOINLINE readWord8ArrayAsInt64# #-}
+readWord8ArrayAsInt64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int# #)
+readWord8ArrayAsInt64# a1 a2 a3 = (GHC.Prim.readWord8ArrayAsInt64#) a1 a2 a3
+{-# NOINLINE readWord8ArrayAsInt# #-}
+readWord8ArrayAsInt# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int# #)
+readWord8ArrayAsInt# a1 a2 a3 = (GHC.Prim.readWord8ArrayAsInt#) a1 a2 a3
+{-# NOINLINE readWord8ArrayAsWord16# #-}
+readWord8ArrayAsWord16# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word# #)
+readWord8ArrayAsWord16# a1 a2 a3 = (GHC.Prim.readWord8ArrayAsWord16#) a1 a2 a3
+{-# NOINLINE readWord8ArrayAsWord32# #-}
+readWord8ArrayAsWord32# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word# #)
+readWord8ArrayAsWord32# a1 a2 a3 = (GHC.Prim.readWord8ArrayAsWord32#) a1 a2 a3
+{-# NOINLINE readWord8ArrayAsWord64# #-}
+readWord8ArrayAsWord64# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word# #)
+readWord8ArrayAsWord64# a1 a2 a3 = (GHC.Prim.readWord8ArrayAsWord64#) a1 a2 a3
+{-# NOINLINE readWord8ArrayAsWord# #-}
+readWord8ArrayAsWord# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Word# #)
+readWord8ArrayAsWord# a1 a2 a3 = (GHC.Prim.readWord8ArrayAsWord#) a1 a2 a3
+{-# NOINLINE writeCharArray# #-}
+writeCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
+writeCharArray# a1 a2 a3 a4 = (GHC.Prim.writeCharArray#) a1 a2 a3 a4
+{-# NOINLINE writeWideCharArray# #-}
+writeWideCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
+writeWideCharArray# a1 a2 a3 a4 = (GHC.Prim.writeWideCharArray#) a1 a2 a3 a4
+{-# NOINLINE writeIntArray# #-}
+writeIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
+writeIntArray# a1 a2 a3 a4 = (GHC.Prim.writeIntArray#) a1 a2 a3 a4
+{-# NOINLINE writeWordArray# #-}
+writeWordArray# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
+writeWordArray# a1 a2 a3 a4 = (GHC.Prim.writeWordArray#) a1 a2 a3 a4
+{-# NOINLINE writeAddrArray# #-}
+writeAddrArray# :: MutableByteArray# s -> Int# -> Addr# -> State# s -> State# s
+writeAddrArray# a1 a2 a3 a4 = (GHC.Prim.writeAddrArray#) a1 a2 a3 a4
+{-# NOINLINE writeFloatArray# #-}
+writeFloatArray# :: MutableByteArray# s -> Int# -> Float# -> State# s -> State# s
+writeFloatArray# a1 a2 a3 a4 = (GHC.Prim.writeFloatArray#) a1 a2 a3 a4
+{-# NOINLINE writeDoubleArray# #-}
+writeDoubleArray# :: MutableByteArray# s -> Int# -> Double# -> State# s -> State# s
+writeDoubleArray# a1 a2 a3 a4 = (GHC.Prim.writeDoubleArray#) a1 a2 a3 a4
+{-# NOINLINE writeStablePtrArray# #-}
+writeStablePtrArray# :: MutableByteArray# s -> Int# -> StablePtr# a -> State# s -> State# s
+writeStablePtrArray# a1 a2 a3 a4 = (GHC.Prim.writeStablePtrArray#) a1 a2 a3 a4
+{-# NOINLINE writeInt8Array# #-}
+writeInt8Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
+writeInt8Array# a1 a2 a3 a4 = (GHC.Prim.writeInt8Array#) a1 a2 a3 a4
+{-# NOINLINE writeInt16Array# #-}
+writeInt16Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
+writeInt16Array# a1 a2 a3 a4 = (GHC.Prim.writeInt16Array#) a1 a2 a3 a4
+{-# NOINLINE writeInt32Array# #-}
+writeInt32Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
+writeInt32Array# a1 a2 a3 a4 = (GHC.Prim.writeInt32Array#) a1 a2 a3 a4
+{-# NOINLINE writeInt64Array# #-}
+writeInt64Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
+writeInt64Array# a1 a2 a3 a4 = (GHC.Prim.writeInt64Array#) a1 a2 a3 a4
+{-# NOINLINE writeWord8Array# #-}
+writeWord8Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
+writeWord8Array# a1 a2 a3 a4 = (GHC.Prim.writeWord8Array#) a1 a2 a3 a4
+{-# NOINLINE writeWord16Array# #-}
+writeWord16Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
+writeWord16Array# a1 a2 a3 a4 = (GHC.Prim.writeWord16Array#) a1 a2 a3 a4
+{-# NOINLINE writeWord32Array# #-}
+writeWord32Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
+writeWord32Array# a1 a2 a3 a4 = (GHC.Prim.writeWord32Array#) a1 a2 a3 a4
+{-# NOINLINE writeWord64Array# #-}
+writeWord64Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
+writeWord64Array# a1 a2 a3 a4 = (GHC.Prim.writeWord64Array#) a1 a2 a3 a4
+{-# NOINLINE writeWord8ArrayAsChar# #-}
+writeWord8ArrayAsChar# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
+writeWord8ArrayAsChar# a1 a2 a3 a4 = (GHC.Prim.writeWord8ArrayAsChar#) a1 a2 a3 a4
+{-# NOINLINE writeWord8ArrayAsWideChar# #-}
+writeWord8ArrayAsWideChar# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
+writeWord8ArrayAsWideChar# a1 a2 a3 a4 = (GHC.Prim.writeWord8ArrayAsWideChar#) a1 a2 a3 a4
+{-# NOINLINE writeWord8ArrayAsAddr# #-}
+writeWord8ArrayAsAddr# :: MutableByteArray# s -> Int# -> Addr# -> State# s -> State# s
+writeWord8ArrayAsAddr# a1 a2 a3 a4 = (GHC.Prim.writeWord8ArrayAsAddr#) a1 a2 a3 a4
+{-# NOINLINE writeWord8ArrayAsFloat# #-}
+writeWord8ArrayAsFloat# :: MutableByteArray# s -> Int# -> Float# -> State# s -> State# s
+writeWord8ArrayAsFloat# a1 a2 a3 a4 = (GHC.Prim.writeWord8ArrayAsFloat#) a1 a2 a3 a4
+{-# NOINLINE writeWord8ArrayAsDouble# #-}
+writeWord8ArrayAsDouble# :: MutableByteArray# s -> Int# -> Double# -> State# s -> State# s
+writeWord8ArrayAsDouble# a1 a2 a3 a4 = (GHC.Prim.writeWord8ArrayAsDouble#) a1 a2 a3 a4
+{-# NOINLINE writeWord8ArrayAsStablePtr# #-}
+writeWord8ArrayAsStablePtr# :: MutableByteArray# s -> Int# -> StablePtr# a -> State# s -> State# s
+writeWord8ArrayAsStablePtr# a1 a2 a3 a4 = (GHC.Prim.writeWord8ArrayAsStablePtr#) a1 a2 a3 a4
+{-# NOINLINE writeWord8ArrayAsInt16# #-}
+writeWord8ArrayAsInt16# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
+writeWord8ArrayAsInt16# a1 a2 a3 a4 = (GHC.Prim.writeWord8ArrayAsInt16#) a1 a2 a3 a4
+{-# NOINLINE writeWord8ArrayAsInt32# #-}
+writeWord8ArrayAsInt32# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
+writeWord8ArrayAsInt32# a1 a2 a3 a4 = (GHC.Prim.writeWord8ArrayAsInt32#) a1 a2 a3 a4
+{-# NOINLINE writeWord8ArrayAsInt64# #-}
+writeWord8ArrayAsInt64# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
+writeWord8ArrayAsInt64# a1 a2 a3 a4 = (GHC.Prim.writeWord8ArrayAsInt64#) a1 a2 a3 a4
+{-# NOINLINE writeWord8ArrayAsInt# #-}
+writeWord8ArrayAsInt# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
+writeWord8ArrayAsInt# a1 a2 a3 a4 = (GHC.Prim.writeWord8ArrayAsInt#) a1 a2 a3 a4
+{-# NOINLINE writeWord8ArrayAsWord16# #-}
+writeWord8ArrayAsWord16# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
+writeWord8ArrayAsWord16# a1 a2 a3 a4 = (GHC.Prim.writeWord8ArrayAsWord16#) a1 a2 a3 a4
+{-# NOINLINE writeWord8ArrayAsWord32# #-}
+writeWord8ArrayAsWord32# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
+writeWord8ArrayAsWord32# a1 a2 a3 a4 = (GHC.Prim.writeWord8ArrayAsWord32#) a1 a2 a3 a4
+{-# NOINLINE writeWord8ArrayAsWord64# #-}
+writeWord8ArrayAsWord64# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
+writeWord8ArrayAsWord64# a1 a2 a3 a4 = (GHC.Prim.writeWord8ArrayAsWord64#) a1 a2 a3 a4
+{-# NOINLINE writeWord8ArrayAsWord# #-}
+writeWord8ArrayAsWord# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
+writeWord8ArrayAsWord# a1 a2 a3 a4 = (GHC.Prim.writeWord8ArrayAsWord#) a1 a2 a3 a4
+{-# NOINLINE compareByteArrays# #-}
+compareByteArrays# :: ByteArray# -> Int# -> ByteArray# -> Int# -> Int# -> Int#
+compareByteArrays# a1 a2 a3 a4 a5 = (GHC.Prim.compareByteArrays#) a1 a2 a3 a4 a5
+{-# NOINLINE copyByteArray# #-}
+copyByteArray# :: ByteArray# -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
+copyByteArray# a1 a2 a3 a4 a5 a6 = (GHC.Prim.copyByteArray#) a1 a2 a3 a4 a5 a6
+{-# NOINLINE copyMutableByteArray# #-}
+copyMutableByteArray# :: MutableByteArray# s -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
+copyMutableByteArray# a1 a2 a3 a4 a5 a6 = (GHC.Prim.copyMutableByteArray#) a1 a2 a3 a4 a5 a6
+{-# NOINLINE copyByteArrayToAddr# #-}
+copyByteArrayToAddr# :: ByteArray# -> Int# -> Addr# -> Int# -> State# s -> State# s
+copyByteArrayToAddr# a1 a2 a3 a4 a5 = (GHC.Prim.copyByteArrayToAddr#) a1 a2 a3 a4 a5
+{-# NOINLINE copyMutableByteArrayToAddr# #-}
+copyMutableByteArrayToAddr# :: MutableByteArray# s -> Int# -> Addr# -> Int# -> State# s -> State# s
+copyMutableByteArrayToAddr# a1 a2 a3 a4 a5 = (GHC.Prim.copyMutableByteArrayToAddr#) a1 a2 a3 a4 a5
+{-# NOINLINE copyAddrToByteArray# #-}
+copyAddrToByteArray# :: Addr# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
+copyAddrToByteArray# a1 a2 a3 a4 a5 = (GHC.Prim.copyAddrToByteArray#) a1 a2 a3 a4 a5
+{-# NOINLINE setByteArray# #-}
+setByteArray# :: MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> State# s
+setByteArray# a1 a2 a3 a4 a5 = (GHC.Prim.setByteArray#) a1 a2 a3 a4 a5
+{-# NOINLINE atomicReadIntArray# #-}
+atomicReadIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s,Int# #)
+atomicReadIntArray# a1 a2 a3 = (GHC.Prim.atomicReadIntArray#) a1 a2 a3
+{-# NOINLINE atomicWriteIntArray# #-}
+atomicWriteIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
+atomicWriteIntArray# a1 a2 a3 a4 = (GHC.Prim.atomicWriteIntArray#) a1 a2 a3 a4
+{-# NOINLINE casIntArray# #-}
+casIntArray# :: MutableByteArray# s -> Int# -> Int# -> Int# -> State# s -> (# State# s,Int# #)
+casIntArray# a1 a2 a3 a4 a5 = (GHC.Prim.casIntArray#) a1 a2 a3 a4 a5
+{-# NOINLINE fetchAddIntArray# #-}
+fetchAddIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s,Int# #)
+fetchAddIntArray# a1 a2 a3 a4 = (GHC.Prim.fetchAddIntArray#) a1 a2 a3 a4
+{-# NOINLINE fetchSubIntArray# #-}
+fetchSubIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s,Int# #)
+fetchSubIntArray# a1 a2 a3 a4 = (GHC.Prim.fetchSubIntArray#) a1 a2 a3 a4
+{-# NOINLINE fetchAndIntArray# #-}
+fetchAndIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s,Int# #)
+fetchAndIntArray# a1 a2 a3 a4 = (GHC.Prim.fetchAndIntArray#) a1 a2 a3 a4
+{-# NOINLINE fetchNandIntArray# #-}
+fetchNandIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s,Int# #)
+fetchNandIntArray# a1 a2 a3 a4 = (GHC.Prim.fetchNandIntArray#) a1 a2 a3 a4
+{-# NOINLINE fetchOrIntArray# #-}
+fetchOrIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s,Int# #)
+fetchOrIntArray# a1 a2 a3 a4 = (GHC.Prim.fetchOrIntArray#) a1 a2 a3 a4
+{-# NOINLINE fetchXorIntArray# #-}
+fetchXorIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> (# State# s,Int# #)
+fetchXorIntArray# a1 a2 a3 a4 = (GHC.Prim.fetchXorIntArray#) a1 a2 a3 a4
+{-# NOINLINE newArrayArray# #-}
+newArrayArray# :: Int# -> State# s -> (# State# s,MutableArrayArray# s #)
+newArrayArray# a1 a2 = (GHC.Prim.newArrayArray#) a1 a2
+{-# NOINLINE sameMutableArrayArray# #-}
+sameMutableArrayArray# :: MutableArrayArray# s -> MutableArrayArray# s -> Int#
+sameMutableArrayArray# a1 a2 = (GHC.Prim.sameMutableArrayArray#) a1 a2
+{-# NOINLINE unsafeFreezeArrayArray# #-}
+unsafeFreezeArrayArray# :: MutableArrayArray# s -> State# s -> (# State# s,ArrayArray# #)
+unsafeFreezeArrayArray# a1 a2 = (GHC.Prim.unsafeFreezeArrayArray#) a1 a2
+{-# NOINLINE sizeofArrayArray# #-}
+sizeofArrayArray# :: ArrayArray# -> Int#
+sizeofArrayArray# a1 = (GHC.Prim.sizeofArrayArray#) a1
+{-# NOINLINE sizeofMutableArrayArray# #-}
+sizeofMutableArrayArray# :: MutableArrayArray# s -> Int#
+sizeofMutableArrayArray# a1 = (GHC.Prim.sizeofMutableArrayArray#) a1
+{-# NOINLINE indexByteArrayArray# #-}
+indexByteArrayArray# :: ArrayArray# -> Int# -> ByteArray#
+indexByteArrayArray# a1 a2 = (GHC.Prim.indexByteArrayArray#) a1 a2
+{-# NOINLINE indexArrayArrayArray# #-}
+indexArrayArrayArray# :: ArrayArray# -> Int# -> ArrayArray#
+indexArrayArrayArray# a1 a2 = (GHC.Prim.indexArrayArrayArray#) a1 a2
+{-# NOINLINE readByteArrayArray# #-}
+readByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s,ByteArray# #)
+readByteArrayArray# a1 a2 a3 = (GHC.Prim.readByteArrayArray#) a1 a2 a3
+{-# NOINLINE readMutableByteArrayArray# #-}
+readMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s,MutableByteArray# s #)
+readMutableByteArrayArray# a1 a2 a3 = (GHC.Prim.readMutableByteArrayArray#) a1 a2 a3
+{-# NOINLINE readArrayArrayArray# #-}
+readArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s,ArrayArray# #)
+readArrayArrayArray# a1 a2 a3 = (GHC.Prim.readArrayArrayArray#) a1 a2 a3
+{-# NOINLINE readMutableArrayArrayArray# #-}
+readMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s,MutableArrayArray# s #)
+readMutableArrayArrayArray# a1 a2 a3 = (GHC.Prim.readMutableArrayArrayArray#) a1 a2 a3
+{-# NOINLINE writeByteArrayArray# #-}
+writeByteArrayArray# :: MutableArrayArray# s -> Int# -> ByteArray# -> State# s -> State# s
+writeByteArrayArray# a1 a2 a3 a4 = (GHC.Prim.writeByteArrayArray#) a1 a2 a3 a4
+{-# NOINLINE writeMutableByteArrayArray# #-}
+writeMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> MutableByteArray# s -> State# s -> State# s
+writeMutableByteArrayArray# a1 a2 a3 a4 = (GHC.Prim.writeMutableByteArrayArray#) a1 a2 a3 a4
+{-# NOINLINE writeArrayArrayArray# #-}
+writeArrayArrayArray# :: MutableArrayArray# s -> Int# -> ArrayArray# -> State# s -> State# s
+writeArrayArrayArray# a1 a2 a3 a4 = (GHC.Prim.writeArrayArrayArray#) a1 a2 a3 a4
+{-# NOINLINE writeMutableArrayArrayArray# #-}
+writeMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> State# s -> State# s
+writeMutableArrayArrayArray# a1 a2 a3 a4 = (GHC.Prim.writeMutableArrayArrayArray#) a1 a2 a3 a4
+{-# NOINLINE copyArrayArray# #-}
+copyArrayArray# :: ArrayArray# -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s
+copyArrayArray# a1 a2 a3 a4 a5 a6 = (GHC.Prim.copyArrayArray#) a1 a2 a3 a4 a5 a6
+{-# NOINLINE copyMutableArrayArray# #-}
+copyMutableArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s
+copyMutableArrayArray# a1 a2 a3 a4 a5 a6 = (GHC.Prim.copyMutableArrayArray#) a1 a2 a3 a4 a5 a6
+{-# NOINLINE plusAddr# #-}
+plusAddr# :: Addr# -> Int# -> Addr#
+plusAddr# a1 a2 = (GHC.Prim.plusAddr#) a1 a2
+{-# NOINLINE minusAddr# #-}
+minusAddr# :: Addr# -> Addr# -> Int#
+minusAddr# a1 a2 = (GHC.Prim.minusAddr#) a1 a2
+{-# NOINLINE remAddr# #-}
+remAddr# :: Addr# -> Int# -> Int#
+remAddr# a1 a2 = (GHC.Prim.remAddr#) a1 a2
+{-# NOINLINE addr2Int# #-}
+addr2Int# :: Addr# -> Int#
+addr2Int# a1 = (GHC.Prim.addr2Int#) a1
+{-# NOINLINE int2Addr# #-}
+int2Addr# :: Int# -> Addr#
+int2Addr# a1 = (GHC.Prim.int2Addr#) a1
+{-# NOINLINE gtAddr# #-}
+gtAddr# :: Addr# -> Addr# -> Int#
+gtAddr# a1 a2 = (GHC.Prim.gtAddr#) a1 a2
+{-# NOINLINE geAddr# #-}
+geAddr# :: Addr# -> Addr# -> Int#
+geAddr# a1 a2 = (GHC.Prim.geAddr#) a1 a2
+{-# NOINLINE eqAddr# #-}
+eqAddr# :: Addr# -> Addr# -> Int#
+eqAddr# a1 a2 = (GHC.Prim.eqAddr#) a1 a2
+{-# NOINLINE neAddr# #-}
+neAddr# :: Addr# -> Addr# -> Int#
+neAddr# a1 a2 = (GHC.Prim.neAddr#) a1 a2
+{-# NOINLINE ltAddr# #-}
+ltAddr# :: Addr# -> Addr# -> Int#
+ltAddr# a1 a2 = (GHC.Prim.ltAddr#) a1 a2
+{-# NOINLINE leAddr# #-}
+leAddr# :: Addr# -> Addr# -> Int#
+leAddr# a1 a2 = (GHC.Prim.leAddr#) a1 a2
+{-# NOINLINE indexCharOffAddr# #-}
+indexCharOffAddr# :: Addr# -> Int# -> Char#
+indexCharOffAddr# a1 a2 = (GHC.Prim.indexCharOffAddr#) a1 a2
+{-# NOINLINE indexWideCharOffAddr# #-}
+indexWideCharOffAddr# :: Addr# -> Int# -> Char#
+indexWideCharOffAddr# a1 a2 = (GHC.Prim.indexWideCharOffAddr#) a1 a2
+{-# NOINLINE indexIntOffAddr# #-}
+indexIntOffAddr# :: Addr# -> Int# -> Int#
+indexIntOffAddr# a1 a2 = (GHC.Prim.indexIntOffAddr#) a1 a2
+{-# NOINLINE indexWordOffAddr# #-}
+indexWordOffAddr# :: Addr# -> Int# -> Word#
+indexWordOffAddr# a1 a2 = (GHC.Prim.indexWordOffAddr#) a1 a2
+{-# NOINLINE indexAddrOffAddr# #-}
+indexAddrOffAddr# :: Addr# -> Int# -> Addr#
+indexAddrOffAddr# a1 a2 = (GHC.Prim.indexAddrOffAddr#) a1 a2
+{-# NOINLINE indexFloatOffAddr# #-}
+indexFloatOffAddr# :: Addr# -> Int# -> Float#
+indexFloatOffAddr# a1 a2 = (GHC.Prim.indexFloatOffAddr#) a1 a2
+{-# NOINLINE indexDoubleOffAddr# #-}
+indexDoubleOffAddr# :: Addr# -> Int# -> Double#
+indexDoubleOffAddr# a1 a2 = (GHC.Prim.indexDoubleOffAddr#) a1 a2
+{-# NOINLINE indexStablePtrOffAddr# #-}
+indexStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a
+indexStablePtrOffAddr# a1 a2 = (GHC.Prim.indexStablePtrOffAddr#) a1 a2
+{-# NOINLINE indexInt8OffAddr# #-}
+indexInt8OffAddr# :: Addr# -> Int# -> Int#
+indexInt8OffAddr# a1 a2 = (GHC.Prim.indexInt8OffAddr#) a1 a2
+{-# NOINLINE indexInt16OffAddr# #-}
+indexInt16OffAddr# :: Addr# -> Int# -> Int#
+indexInt16OffAddr# a1 a2 = (GHC.Prim.indexInt16OffAddr#) a1 a2
+{-# NOINLINE indexInt32OffAddr# #-}
+indexInt32OffAddr# :: Addr# -> Int# -> Int#
+indexInt32OffAddr# a1 a2 = (GHC.Prim.indexInt32OffAddr#) a1 a2
+{-# NOINLINE indexInt64OffAddr# #-}
+indexInt64OffAddr# :: Addr# -> Int# -> Int#
+indexInt64OffAddr# a1 a2 = (GHC.Prim.indexInt64OffAddr#) a1 a2
+{-# NOINLINE indexWord8OffAddr# #-}
+indexWord8OffAddr# :: Addr# -> Int# -> Word#
+indexWord8OffAddr# a1 a2 = (GHC.Prim.indexWord8OffAddr#) a1 a2
+{-# NOINLINE indexWord16OffAddr# #-}
+indexWord16OffAddr# :: Addr# -> Int# -> Word#
+indexWord16OffAddr# a1 a2 = (GHC.Prim.indexWord16OffAddr#) a1 a2
+{-# NOINLINE indexWord32OffAddr# #-}
+indexWord32OffAddr# :: Addr# -> Int# -> Word#
+indexWord32OffAddr# a1 a2 = (GHC.Prim.indexWord32OffAddr#) a1 a2
+{-# NOINLINE indexWord64OffAddr# #-}
+indexWord64OffAddr# :: Addr# -> Int# -> Word#
+indexWord64OffAddr# a1 a2 = (GHC.Prim.indexWord64OffAddr#) a1 a2
+{-# NOINLINE readCharOffAddr# #-}
+readCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Char# #)
+readCharOffAddr# a1 a2 a3 = (GHC.Prim.readCharOffAddr#) a1 a2 a3
+{-# NOINLINE readWideCharOffAddr# #-}
+readWideCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Char# #)
+readWideCharOffAddr# a1 a2 a3 = (GHC.Prim.readWideCharOffAddr#) a1 a2 a3
+{-# NOINLINE readIntOffAddr# #-}
+readIntOffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Int# #)
+readIntOffAddr# a1 a2 a3 = (GHC.Prim.readIntOffAddr#) a1 a2 a3
+{-# NOINLINE readWordOffAddr# #-}
+readWordOffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Word# #)
+readWordOffAddr# a1 a2 a3 = (GHC.Prim.readWordOffAddr#) a1 a2 a3
+{-# NOINLINE readAddrOffAddr# #-}
+readAddrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Addr# #)
+readAddrOffAddr# a1 a2 a3 = (GHC.Prim.readAddrOffAddr#) a1 a2 a3
+{-# NOINLINE readFloatOffAddr# #-}
+readFloatOffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Float# #)
+readFloatOffAddr# a1 a2 a3 = (GHC.Prim.readFloatOffAddr#) a1 a2 a3
+{-# NOINLINE readDoubleOffAddr# #-}
+readDoubleOffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Double# #)
+readDoubleOffAddr# a1 a2 a3 = (GHC.Prim.readDoubleOffAddr#) a1 a2 a3
+{-# NOINLINE readStablePtrOffAddr# #-}
+readStablePtrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s,StablePtr# a #)
+readStablePtrOffAddr# a1 a2 a3 = (GHC.Prim.readStablePtrOffAddr#) a1 a2 a3
+{-# NOINLINE readInt8OffAddr# #-}
+readInt8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Int# #)
+readInt8OffAddr# a1 a2 a3 = (GHC.Prim.readInt8OffAddr#) a1 a2 a3
+{-# NOINLINE readInt16OffAddr# #-}
+readInt16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Int# #)
+readInt16OffAddr# a1 a2 a3 = (GHC.Prim.readInt16OffAddr#) a1 a2 a3
+{-# NOINLINE readInt32OffAddr# #-}
+readInt32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Int# #)
+readInt32OffAddr# a1 a2 a3 = (GHC.Prim.readInt32OffAddr#) a1 a2 a3
+{-# NOINLINE readInt64OffAddr# #-}
+readInt64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Int# #)
+readInt64OffAddr# a1 a2 a3 = (GHC.Prim.readInt64OffAddr#) a1 a2 a3
+{-# NOINLINE readWord8OffAddr# #-}
+readWord8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Word# #)
+readWord8OffAddr# a1 a2 a3 = (GHC.Prim.readWord8OffAddr#) a1 a2 a3
+{-# NOINLINE readWord16OffAddr# #-}
+readWord16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Word# #)
+readWord16OffAddr# a1 a2 a3 = (GHC.Prim.readWord16OffAddr#) a1 a2 a3
+{-# NOINLINE readWord32OffAddr# #-}
+readWord32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Word# #)
+readWord32OffAddr# a1 a2 a3 = (GHC.Prim.readWord32OffAddr#) a1 a2 a3
+{-# NOINLINE readWord64OffAddr# #-}
+readWord64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s,Word# #)
+readWord64OffAddr# a1 a2 a3 = (GHC.Prim.readWord64OffAddr#) a1 a2 a3
+{-# NOINLINE writeCharOffAddr# #-}
+writeCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s
+writeCharOffAddr# a1 a2 a3 a4 = (GHC.Prim.writeCharOffAddr#) a1 a2 a3 a4
+{-# NOINLINE writeWideCharOffAddr# #-}
+writeWideCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s
+writeWideCharOffAddr# a1 a2 a3 a4 = (GHC.Prim.writeWideCharOffAddr#) a1 a2 a3 a4
+{-# NOINLINE writeIntOffAddr# #-}
+writeIntOffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
+writeIntOffAddr# a1 a2 a3 a4 = (GHC.Prim.writeIntOffAddr#) a1 a2 a3 a4
+{-# NOINLINE writeWordOffAddr# #-}
+writeWordOffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
+writeWordOffAddr# a1 a2 a3 a4 = (GHC.Prim.writeWordOffAddr#) a1 a2 a3 a4
+{-# NOINLINE writeAddrOffAddr# #-}
+writeAddrOffAddr# :: Addr# -> Int# -> Addr# -> State# s -> State# s
+writeAddrOffAddr# a1 a2 a3 a4 = (GHC.Prim.writeAddrOffAddr#) a1 a2 a3 a4
+{-# NOINLINE writeFloatOffAddr# #-}
+writeFloatOffAddr# :: Addr# -> Int# -> Float# -> State# s -> State# s
+writeFloatOffAddr# a1 a2 a3 a4 = (GHC.Prim.writeFloatOffAddr#) a1 a2 a3 a4
+{-# NOINLINE writeDoubleOffAddr# #-}
+writeDoubleOffAddr# :: Addr# -> Int# -> Double# -> State# s -> State# s
+writeDoubleOffAddr# a1 a2 a3 a4 = (GHC.Prim.writeDoubleOffAddr#) a1 a2 a3 a4
+{-# NOINLINE writeStablePtrOffAddr# #-}
+writeStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a -> State# s -> State# s
+writeStablePtrOffAddr# a1 a2 a3 a4 = (GHC.Prim.writeStablePtrOffAddr#) a1 a2 a3 a4
+{-# NOINLINE writeInt8OffAddr# #-}
+writeInt8OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
+writeInt8OffAddr# a1 a2 a3 a4 = (GHC.Prim.writeInt8OffAddr#) a1 a2 a3 a4
+{-# NOINLINE writeInt16OffAddr# #-}
+writeInt16OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
+writeInt16OffAddr# a1 a2 a3 a4 = (GHC.Prim.writeInt16OffAddr#) a1 a2 a3 a4
+{-# NOINLINE writeInt32OffAddr# #-}
+writeInt32OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
+writeInt32OffAddr# a1 a2 a3 a4 = (GHC.Prim.writeInt32OffAddr#) a1 a2 a3 a4
+{-# NOINLINE writeInt64OffAddr# #-}
+writeInt64OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
+writeInt64OffAddr# a1 a2 a3 a4 = (GHC.Prim.writeInt64OffAddr#) a1 a2 a3 a4
+{-# NOINLINE writeWord8OffAddr# #-}
+writeWord8OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
+writeWord8OffAddr# a1 a2 a3 a4 = (GHC.Prim.writeWord8OffAddr#) a1 a2 a3 a4
+{-# NOINLINE writeWord16OffAddr# #-}
+writeWord16OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
+writeWord16OffAddr# a1 a2 a3 a4 = (GHC.Prim.writeWord16OffAddr#) a1 a2 a3 a4
+{-# NOINLINE writeWord32OffAddr# #-}
+writeWord32OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
+writeWord32OffAddr# a1 a2 a3 a4 = (GHC.Prim.writeWord32OffAddr#) a1 a2 a3 a4
+{-# NOINLINE writeWord64OffAddr# #-}
+writeWord64OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
+writeWord64OffAddr# a1 a2 a3 a4 = (GHC.Prim.writeWord64OffAddr#) a1 a2 a3 a4
+{-# NOINLINE newMutVar# #-}
+newMutVar# :: a -> State# s -> (# State# s,MutVar# s a #)
+newMutVar# a1 a2 = (GHC.Prim.newMutVar#) a1 a2
+{-# NOINLINE readMutVar# #-}
+readMutVar# :: MutVar# s a -> State# s -> (# State# s,a #)
+readMutVar# a1 a2 = (GHC.Prim.readMutVar#) a1 a2
+{-# NOINLINE writeMutVar# #-}
+writeMutVar# :: MutVar# s a -> a -> State# s -> State# s
+writeMutVar# a1 a2 a3 = (GHC.Prim.writeMutVar#) a1 a2 a3
+{-# NOINLINE sameMutVar# #-}
+sameMutVar# :: MutVar# s a -> MutVar# s a -> Int#
+sameMutVar# a1 a2 = (GHC.Prim.sameMutVar#) a1 a2
+{-# NOINLINE atomicModifyMutVar2# #-}
+atomicModifyMutVar2# :: MutVar# s a -> (a -> c) -> State# s -> (# State# s,a,c #)
+atomicModifyMutVar2# a1 a2 a3 = (GHC.Prim.atomicModifyMutVar2#) a1 a2 a3
+{-# NOINLINE atomicModifyMutVar_# #-}
+atomicModifyMutVar_# :: MutVar# s a -> (a -> a) -> State# s -> (# State# s,a,a #)
+atomicModifyMutVar_# a1 a2 a3 = (GHC.Prim.atomicModifyMutVar_#) a1 a2 a3
+{-# NOINLINE casMutVar# #-}
+casMutVar# :: MutVar# s a -> a -> a -> State# s -> (# State# s,Int#,a #)
+casMutVar# a1 a2 a3 a4 = (GHC.Prim.casMutVar#) a1 a2 a3 a4
+{-# NOINLINE catch# #-}
+catch# :: (State# (RealWorld) -> (# State# (RealWorld),a #)) -> (b -> State# (RealWorld) -> (# State# (RealWorld),a #)) -> State# (RealWorld) -> (# State# (RealWorld),a #)
+catch# a1 a2 a3 = (GHC.Prim.catch#) a1 a2 a3
+{-# NOINLINE raise# #-}
+raise# :: b -> o
+raise# a1 = (GHC.Prim.raise#) a1
+{-# NOINLINE raiseIO# #-}
+raiseIO# :: a -> State# (RealWorld) -> (# State# (RealWorld),b #)
+raiseIO# a1 a2 = (GHC.Prim.raiseIO#) a1 a2
+{-# NOINLINE maskAsyncExceptions# #-}
+maskAsyncExceptions# :: (State# (RealWorld) -> (# State# (RealWorld),a #)) -> State# (RealWorld) -> (# State# (RealWorld),a #)
+maskAsyncExceptions# a1 a2 = (GHC.Prim.maskAsyncExceptions#) a1 a2
+{-# NOINLINE maskUninterruptible# #-}
+maskUninterruptible# :: (State# (RealWorld) -> (# State# (RealWorld),a #)) -> State# (RealWorld) -> (# State# (RealWorld),a #)
+maskUninterruptible# a1 a2 = (GHC.Prim.maskUninterruptible#) a1 a2
+{-# NOINLINE unmaskAsyncExceptions# #-}
+unmaskAsyncExceptions# :: (State# (RealWorld) -> (# State# (RealWorld),a #)) -> State# (RealWorld) -> (# State# (RealWorld),a #)
+unmaskAsyncExceptions# a1 a2 = (GHC.Prim.unmaskAsyncExceptions#) a1 a2
+{-# NOINLINE getMaskingState# #-}
+getMaskingState# :: State# (RealWorld) -> (# State# (RealWorld),Int# #)
+getMaskingState# a1 = (GHC.Prim.getMaskingState#) a1
+{-# NOINLINE atomically# #-}
+atomically# :: (State# (RealWorld) -> (# State# (RealWorld),a #)) -> State# (RealWorld) -> (# State# (RealWorld),a #)
+atomically# a1 a2 = (GHC.Prim.atomically#) a1 a2
+{-# NOINLINE retry# #-}
+retry# :: State# (RealWorld) -> (# State# (RealWorld),a #)
+retry# a1 = (GHC.Prim.retry#) a1
+{-# NOINLINE catchRetry# #-}
+catchRetry# :: (State# (RealWorld) -> (# State# (RealWorld),a #)) -> (State# (RealWorld) -> (# State# (RealWorld),a #)) -> State# (RealWorld) -> (# State# (RealWorld),a #)
+catchRetry# a1 a2 a3 = (GHC.Prim.catchRetry#) a1 a2 a3
+{-# NOINLINE catchSTM# #-}
+catchSTM# :: (State# (RealWorld) -> (# State# (RealWorld),a #)) -> (b -> State# (RealWorld) -> (# State# (RealWorld),a #)) -> State# (RealWorld) -> (# State# (RealWorld),a #)
+catchSTM# a1 a2 a3 = (GHC.Prim.catchSTM#) a1 a2 a3
+{-# NOINLINE newTVar# #-}
+newTVar# :: a -> State# s -> (# State# s,TVar# s a #)
+newTVar# a1 a2 = (GHC.Prim.newTVar#) a1 a2
+{-# NOINLINE readTVar# #-}
+readTVar# :: TVar# s a -> State# s -> (# State# s,a #)
+readTVar# a1 a2 = (GHC.Prim.readTVar#) a1 a2
+{-# NOINLINE readTVarIO# #-}
+readTVarIO# :: TVar# s a -> State# s -> (# State# s,a #)
+readTVarIO# a1 a2 = (GHC.Prim.readTVarIO#) a1 a2
+{-# NOINLINE writeTVar# #-}
+writeTVar# :: TVar# s a -> a -> State# s -> State# s
+writeTVar# a1 a2 a3 = (GHC.Prim.writeTVar#) a1 a2 a3
+{-# NOINLINE sameTVar# #-}
+sameTVar# :: TVar# s a -> TVar# s a -> Int#
+sameTVar# a1 a2 = (GHC.Prim.sameTVar#) a1 a2
+{-# NOINLINE newMVar# #-}
+newMVar# :: State# s -> (# State# s,MVar# s a #)
+newMVar# a1 = (GHC.Prim.newMVar#) a1
+{-# NOINLINE takeMVar# #-}
+takeMVar# :: MVar# s a -> State# s -> (# State# s,a #)
+takeMVar# a1 a2 = (GHC.Prim.takeMVar#) a1 a2
+{-# NOINLINE tryTakeMVar# #-}
+tryTakeMVar# :: MVar# s a -> State# s -> (# State# s,Int#,a #)
+tryTakeMVar# a1 a2 = (GHC.Prim.tryTakeMVar#) a1 a2
+{-# NOINLINE putMVar# #-}
+putMVar# :: MVar# s a -> a -> State# s -> State# s
+putMVar# a1 a2 a3 = (GHC.Prim.putMVar#) a1 a2 a3
+{-# NOINLINE tryPutMVar# #-}
+tryPutMVar# :: MVar# s a -> a -> State# s -> (# State# s,Int# #)
+tryPutMVar# a1 a2 a3 = (GHC.Prim.tryPutMVar#) a1 a2 a3
+{-# NOINLINE readMVar# #-}
+readMVar# :: MVar# s a -> State# s -> (# State# s,a #)
+readMVar# a1 a2 = (GHC.Prim.readMVar#) a1 a2
+{-# NOINLINE tryReadMVar# #-}
+tryReadMVar# :: MVar# s a -> State# s -> (# State# s,Int#,a #)
+tryReadMVar# a1 a2 = (GHC.Prim.tryReadMVar#) a1 a2
+{-# NOINLINE sameMVar# #-}
+sameMVar# :: MVar# s a -> MVar# s a -> Int#
+sameMVar# a1 a2 = (GHC.Prim.sameMVar#) a1 a2
+{-# NOINLINE isEmptyMVar# #-}
+isEmptyMVar# :: MVar# s a -> State# s -> (# State# s,Int# #)
+isEmptyMVar# a1 a2 = (GHC.Prim.isEmptyMVar#) a1 a2
+{-# NOINLINE delay# #-}
+delay# :: Int# -> State# s -> State# s
+delay# a1 a2 = (GHC.Prim.delay#) a1 a2
+{-# NOINLINE waitRead# #-}
+waitRead# :: Int# -> State# s -> State# s
+waitRead# a1 a2 = (GHC.Prim.waitRead#) a1 a2
+{-# NOINLINE waitWrite# #-}
+waitWrite# :: Int# -> State# s -> State# s
+waitWrite# a1 a2 = (GHC.Prim.waitWrite#) a1 a2
+#if defined(mingw32_HOST_OS)
+{-# NOINLINE asyncRead# #-}
+asyncRead# :: Int# -> Int# -> Int# -> Addr# -> State# (RealWorld) -> (# State# (RealWorld),Int#,Int# #)
+asyncRead# a1 a2 a3 a4 a5 = (GHC.Prim.asyncRead#) a1 a2 a3 a4 a5
+{-# NOINLINE asyncWrite# #-}
+asyncWrite# :: Int# -> Int# -> Int# -> Addr# -> State# (RealWorld) -> (# State# (RealWorld),Int#,Int# #)
+asyncWrite# a1 a2 a3 a4 a5 = (GHC.Prim.asyncWrite#) a1 a2 a3 a4 a5
+{-# NOINLINE asyncDoProc# #-}
+asyncDoProc# :: Addr# -> Addr# -> State# (RealWorld) -> (# State# (RealWorld),Int#,Int# #)
+asyncDoProc# a1 a2 a3 = (GHC.Prim.asyncDoProc#) a1 a2 a3
+#endif
+{-# NOINLINE fork# #-}
+fork# :: a -> State# (RealWorld) -> (# State# (RealWorld),ThreadId# #)
+fork# a1 a2 = (GHC.Prim.fork#) a1 a2
+{-# NOINLINE forkOn# #-}
+forkOn# :: Int# -> a -> State# (RealWorld) -> (# State# (RealWorld),ThreadId# #)
+forkOn# a1 a2 a3 = (GHC.Prim.forkOn#) a1 a2 a3
+{-# NOINLINE killThread# #-}
+killThread# :: ThreadId# -> a -> State# (RealWorld) -> State# (RealWorld)
+killThread# a1 a2 a3 = (GHC.Prim.killThread#) a1 a2 a3
+{-# NOINLINE yield# #-}
+yield# :: State# (RealWorld) -> State# (RealWorld)
+yield# a1 = (GHC.Prim.yield#) a1
+{-# NOINLINE myThreadId# #-}
+myThreadId# :: State# (RealWorld) -> (# State# (RealWorld),ThreadId# #)
+myThreadId# a1 = (GHC.Prim.myThreadId#) a1
+{-# NOINLINE labelThread# #-}
+labelThread# :: ThreadId# -> Addr# -> State# (RealWorld) -> State# (RealWorld)
+labelThread# a1 a2 a3 = (GHC.Prim.labelThread#) a1 a2 a3
+{-# NOINLINE isCurrentThreadBound# #-}
+isCurrentThreadBound# :: State# (RealWorld) -> (# State# (RealWorld),Int# #)
+isCurrentThreadBound# a1 = (GHC.Prim.isCurrentThreadBound#) a1
+{-# NOINLINE noDuplicate# #-}
+noDuplicate# :: State# s -> State# s
+noDuplicate# a1 = (GHC.Prim.noDuplicate#) a1
+{-# NOINLINE threadStatus# #-}
+threadStatus# :: ThreadId# -> State# (RealWorld) -> (# State# (RealWorld),Int#,Int#,Int# #)
+threadStatus# a1 a2 = (GHC.Prim.threadStatus#) a1 a2
+{-# NOINLINE mkWeak# #-}
+mkWeak# :: o -> b -> (State# (RealWorld) -> (# State# (RealWorld),c #)) -> State# (RealWorld) -> (# State# (RealWorld),Weak# b #)
+mkWeak# a1 a2 a3 a4 = (GHC.Prim.mkWeak#) a1 a2 a3 a4
+{-# NOINLINE mkWeakNoFinalizer# #-}
+mkWeakNoFinalizer# :: o -> b -> State# (RealWorld) -> (# State# (RealWorld),Weak# b #)
+mkWeakNoFinalizer# a1 a2 a3 = (GHC.Prim.mkWeakNoFinalizer#) a1 a2 a3
+{-# NOINLINE addCFinalizerToWeak# #-}
+addCFinalizerToWeak# :: Addr# -> Addr# -> Int# -> Addr# -> Weak# b -> State# (RealWorld) -> (# State# (RealWorld),Int# #)
+addCFinalizerToWeak# a1 a2 a3 a4 a5 a6 = (GHC.Prim.addCFinalizerToWeak#) a1 a2 a3 a4 a5 a6
+{-# NOINLINE deRefWeak# #-}
+deRefWeak# :: Weak# a -> State# (RealWorld) -> (# State# (RealWorld),Int#,a #)
+deRefWeak# a1 a2 = (GHC.Prim.deRefWeak#) a1 a2
+{-# NOINLINE finalizeWeak# #-}
+finalizeWeak# :: Weak# a -> State# (RealWorld) -> (# State# (RealWorld),Int#,State# (RealWorld) -> (# State# (RealWorld),b #) #)
+finalizeWeak# a1 a2 = (GHC.Prim.finalizeWeak#) a1 a2
+{-# NOINLINE touch# #-}
+touch# :: o -> State# (RealWorld) -> State# (RealWorld)
+touch# a1 a2 = (GHC.Prim.touch#) a1 a2
+{-# NOINLINE makeStablePtr# #-}
+makeStablePtr# :: a -> State# (RealWorld) -> (# State# (RealWorld),StablePtr# a #)
+makeStablePtr# a1 a2 = (GHC.Prim.makeStablePtr#) a1 a2
+{-# NOINLINE deRefStablePtr# #-}
+deRefStablePtr# :: StablePtr# a -> State# (RealWorld) -> (# State# (RealWorld),a #)
+deRefStablePtr# a1 a2 = (GHC.Prim.deRefStablePtr#) a1 a2
+{-# NOINLINE eqStablePtr# #-}
+eqStablePtr# :: StablePtr# a -> StablePtr# a -> Int#
+eqStablePtr# a1 a2 = (GHC.Prim.eqStablePtr#) a1 a2
+{-# NOINLINE makeStableName# #-}
+makeStableName# :: a -> State# (RealWorld) -> (# State# (RealWorld),StableName# a #)
+makeStableName# a1 a2 = (GHC.Prim.makeStableName#) a1 a2
+{-# NOINLINE eqStableName# #-}
+eqStableName# :: StableName# a -> StableName# b -> Int#
+eqStableName# a1 a2 = (GHC.Prim.eqStableName#) a1 a2
+{-# NOINLINE stableNameToInt# #-}
+stableNameToInt# :: StableName# a -> Int#
+stableNameToInt# a1 = (GHC.Prim.stableNameToInt#) a1
+{-# NOINLINE compactNew# #-}
+compactNew# :: Word# -> State# (RealWorld) -> (# State# (RealWorld),Compact# #)
+compactNew# a1 a2 = (GHC.Prim.compactNew#) a1 a2
+{-# NOINLINE compactResize# #-}
+compactResize# :: Compact# -> Word# -> State# (RealWorld) -> State# (RealWorld)
+compactResize# a1 a2 a3 = (GHC.Prim.compactResize#) a1 a2 a3
+{-# NOINLINE compactContains# #-}
+compactContains# :: Compact# -> a -> State# (RealWorld) -> (# State# (RealWorld),Int# #)
+compactContains# a1 a2 a3 = (GHC.Prim.compactContains#) a1 a2 a3
+{-# NOINLINE compactContainsAny# #-}
+compactContainsAny# :: a -> State# (RealWorld) -> (# State# (RealWorld),Int# #)
+compactContainsAny# a1 a2 = (GHC.Prim.compactContainsAny#) a1 a2
+{-# NOINLINE compactGetFirstBlock# #-}
+compactGetFirstBlock# :: Compact# -> State# (RealWorld) -> (# State# (RealWorld),Addr#,Word# #)
+compactGetFirstBlock# a1 a2 = (GHC.Prim.compactGetFirstBlock#) a1 a2
+{-# NOINLINE compactGetNextBlock# #-}
+compactGetNextBlock# :: Compact# -> Addr# -> State# (RealWorld) -> (# State# (RealWorld),Addr#,Word# #)
+compactGetNextBlock# a1 a2 a3 = (GHC.Prim.compactGetNextBlock#) a1 a2 a3
+{-# NOINLINE compactAllocateBlock# #-}
+compactAllocateBlock# :: Word# -> Addr# -> State# (RealWorld) -> (# State# (RealWorld),Addr# #)
+compactAllocateBlock# a1 a2 a3 = (GHC.Prim.compactAllocateBlock#) a1 a2 a3
+{-# NOINLINE compactFixupPointers# #-}
+compactFixupPointers# :: Addr# -> Addr# -> State# (RealWorld) -> (# State# (RealWorld),Compact#,Addr# #)
+compactFixupPointers# a1 a2 a3 = (GHC.Prim.compactFixupPointers#) a1 a2 a3
+{-# NOINLINE compactAdd# #-}
+compactAdd# :: Compact# -> a -> State# (RealWorld) -> (# State# (RealWorld),a #)
+compactAdd# a1 a2 a3 = (GHC.Prim.compactAdd#) a1 a2 a3
+{-# NOINLINE compactAddWithSharing# #-}
+compactAddWithSharing# :: Compact# -> a -> State# (RealWorld) -> (# State# (RealWorld),a #)
+compactAddWithSharing# a1 a2 a3 = (GHC.Prim.compactAddWithSharing#) a1 a2 a3
+{-# NOINLINE compactSize# #-}
+compactSize# :: Compact# -> State# (RealWorld) -> (# State# (RealWorld),Word# #)
+compactSize# a1 a2 = (GHC.Prim.compactSize#) a1 a2
+{-# NOINLINE reallyUnsafePtrEquality# #-}
+reallyUnsafePtrEquality# :: a -> a -> Int#
+reallyUnsafePtrEquality# a1 a2 = (GHC.Prim.reallyUnsafePtrEquality#) a1 a2
+{-# NOINLINE par# #-}
+par# :: a -> Int#
+par# a1 = (GHC.Prim.par#) a1
+{-# NOINLINE spark# #-}
+spark# :: a -> State# s -> (# State# s,a #)
+spark# a1 a2 = (GHC.Prim.spark#) a1 a2
+{-# NOINLINE seq# #-}
+seq# :: a -> State# s -> (# State# s,a #)
+seq# a1 a2 = (GHC.Prim.seq#) a1 a2
+{-# NOINLINE getSpark# #-}
+getSpark# :: State# s -> (# State# s,Int#,a #)
+getSpark# a1 = (GHC.Prim.getSpark#) a1
+{-# NOINLINE numSparks# #-}
+numSparks# :: State# s -> (# State# s,Int# #)
+numSparks# a1 = (GHC.Prim.numSparks#) a1
+{-# NOINLINE dataToTag# #-}
+dataToTag# :: a -> Int#
+dataToTag# a1 = (GHC.Prim.dataToTag#) a1
+{-# NOINLINE addrToAny# #-}
+addrToAny# :: Addr# -> (# a #)
+addrToAny# a1 = (GHC.Prim.addrToAny#) a1
+{-# NOINLINE anyToAddr# #-}
+anyToAddr# :: a -> State# (RealWorld) -> (# State# (RealWorld),Addr# #)
+anyToAddr# a1 a2 = (GHC.Prim.anyToAddr#) a1 a2
+{-# NOINLINE mkApUpd0# #-}
+mkApUpd0# :: BCO# -> (# a #)
+mkApUpd0# a1 = (GHC.Prim.mkApUpd0#) a1
+{-# NOINLINE newBCO# #-}
+newBCO# :: ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# s -> (# State# s,BCO# #)
+newBCO# a1 a2 a3 a4 a5 a6 = (GHC.Prim.newBCO#) a1 a2 a3 a4 a5 a6
+{-# NOINLINE unpackClosure# #-}
+unpackClosure# :: a -> (# Addr#,ByteArray#,Array# b #)
+unpackClosure# a1 = (GHC.Prim.unpackClosure#) a1
+{-# NOINLINE closureSize# #-}
+closureSize# :: a -> Int#
+closureSize# a1 = (GHC.Prim.closureSize#) a1
+{-# NOINLINE getApStackVal# #-}
+getApStackVal# :: a -> Int# -> (# Int#,b #)
+getApStackVal# a1 a2 = (GHC.Prim.getApStackVal#) a1 a2
+{-# NOINLINE getCCSOf# #-}
+getCCSOf# :: a -> State# s -> (# State# s,Addr# #)
+getCCSOf# a1 a2 = (GHC.Prim.getCCSOf#) a1 a2
+{-# NOINLINE getCurrentCCS# #-}
+getCurrentCCS# :: a -> State# s -> (# State# s,Addr# #)
+getCurrentCCS# a1 a2 = (GHC.Prim.getCurrentCCS#) a1 a2
+{-# NOINLINE clearCCS# #-}
+clearCCS# :: (State# s -> (# State# s,a #)) -> State# s -> (# State# s,a #)
+clearCCS# a1 a2 = (GHC.Prim.clearCCS#) a1 a2
+{-# NOINLINE traceEvent# #-}
+traceEvent# :: Addr# -> State# s -> State# s
+traceEvent# a1 a2 = (GHC.Prim.traceEvent#) a1 a2
+{-# NOINLINE traceBinaryEvent# #-}
+traceBinaryEvent# :: Addr# -> Int# -> State# s -> State# s
+traceBinaryEvent# a1 a2 a3 = (GHC.Prim.traceBinaryEvent#) a1 a2 a3
+{-# NOINLINE traceMarker# #-}
+traceMarker# :: Addr# -> State# s -> State# s
+traceMarker# a1 a2 = (GHC.Prim.traceMarker#) a1 a2
+{-# NOINLINE getThreadAllocationCounter# #-}
+getThreadAllocationCounter# :: State# (RealWorld) -> (# State# (RealWorld),Int# #)
+getThreadAllocationCounter# a1 = (GHC.Prim.getThreadAllocationCounter#) a1
+{-# NOINLINE setThreadAllocationCounter# #-}
+setThreadAllocationCounter# :: Int# -> State# (RealWorld) -> State# (RealWorld)
+setThreadAllocationCounter# a1 a2 = (GHC.Prim.setThreadAllocationCounter#) a1 a2
+{-# NOINLINE prefetchByteArray3# #-}
+prefetchByteArray3# :: ByteArray# -> Int# -> State# s -> State# s
+prefetchByteArray3# a1 a2 a3 = (GHC.Prim.prefetchByteArray3#) a1 a2 a3
+{-# NOINLINE prefetchMutableByteArray3# #-}
+prefetchMutableByteArray3# :: MutableByteArray# s -> Int# -> State# s -> State# s
+prefetchMutableByteArray3# a1 a2 a3 = (GHC.Prim.prefetchMutableByteArray3#) a1 a2 a3
+{-# NOINLINE prefetchAddr3# #-}
+prefetchAddr3# :: Addr# -> Int# -> State# s -> State# s
+prefetchAddr3# a1 a2 a3 = (GHC.Prim.prefetchAddr3#) a1 a2 a3
+{-# NOINLINE prefetchValue3# #-}
+prefetchValue3# :: a -> State# s -> State# s
+prefetchValue3# a1 a2 = (GHC.Prim.prefetchValue3#) a1 a2
+{-# NOINLINE prefetchByteArray2# #-}
+prefetchByteArray2# :: ByteArray# -> Int# -> State# s -> State# s
+prefetchByteArray2# a1 a2 a3 = (GHC.Prim.prefetchByteArray2#) a1 a2 a3
+{-# NOINLINE prefetchMutableByteArray2# #-}
+prefetchMutableByteArray2# :: MutableByteArray# s -> Int# -> State# s -> State# s
+prefetchMutableByteArray2# a1 a2 a3 = (GHC.Prim.prefetchMutableByteArray2#) a1 a2 a3
+{-# NOINLINE prefetchAddr2# #-}
+prefetchAddr2# :: Addr# -> Int# -> State# s -> State# s
+prefetchAddr2# a1 a2 a3 = (GHC.Prim.prefetchAddr2#) a1 a2 a3
+{-# NOINLINE prefetchValue2# #-}
+prefetchValue2# :: a -> State# s -> State# s
+prefetchValue2# a1 a2 = (GHC.Prim.prefetchValue2#) a1 a2
+{-# NOINLINE prefetchByteArray1# #-}
+prefetchByteArray1# :: ByteArray# -> Int# -> State# s -> State# s
+prefetchByteArray1# a1 a2 a3 = (GHC.Prim.prefetchByteArray1#) a1 a2 a3
+{-# NOINLINE prefetchMutableByteArray1# #-}
+prefetchMutableByteArray1# :: MutableByteArray# s -> Int# -> State# s -> State# s
+prefetchMutableByteArray1# a1 a2 a3 = (GHC.Prim.prefetchMutableByteArray1#) a1 a2 a3
+{-# NOINLINE prefetchAddr1# #-}
+prefetchAddr1# :: Addr# -> Int# -> State# s -> State# s
+prefetchAddr1# a1 a2 a3 = (GHC.Prim.prefetchAddr1#) a1 a2 a3
+{-# NOINLINE prefetchValue1# #-}
+prefetchValue1# :: a -> State# s -> State# s
+prefetchValue1# a1 a2 = (GHC.Prim.prefetchValue1#) a1 a2
+{-# NOINLINE prefetchByteArray0# #-}
+prefetchByteArray0# :: ByteArray# -> Int# -> State# s -> State# s
+prefetchByteArray0# a1 a2 a3 = (GHC.Prim.prefetchByteArray0#) a1 a2 a3
+{-# NOINLINE prefetchMutableByteArray0# #-}
+prefetchMutableByteArray0# :: MutableByteArray# s -> Int# -> State# s -> State# s
+prefetchMutableByteArray0# a1 a2 a3 = (GHC.Prim.prefetchMutableByteArray0#) a1 a2 a3
+{-# NOINLINE prefetchAddr0# #-}
+prefetchAddr0# :: Addr# -> Int# -> State# s -> State# s
+prefetchAddr0# a1 a2 a3 = (GHC.Prim.prefetchAddr0#) a1 a2 a3
+{-# NOINLINE prefetchValue0# #-}
+prefetchValue0# :: a -> State# s -> State# s
+prefetchValue0# a1 a2 = (GHC.Prim.prefetchValue0#) a1 a2
diff -ruN -x '*.rej' -x '*.orig' old/libraries/ghc-prim/Setup.hs new/libraries/ghc-prim/Setup.hs
--- old/libraries/ghc-prim/Setup.hs	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/ghc-prim/Setup.hs	2019-05-13 13:38:44.000000000 +1200
@@ -21,10 +21,8 @@
 main = do let hooks = autoconfUserHooks {
                   regHook = addPrimModule
                           $ regHook simpleUserHooks,
-                  buildHook = build_primitive_sources
-                            $ buildHook simpleUserHooks,
+                  buildHook = buildHook simpleUserHooks,
                   haddockHook = addPrimModuleForHaddock
-                              $ build_primitive_sources
                               $ haddockHook simpleUserHooks }
           defaultMainWithHooks hooks
 
@@ -55,34 +53,3 @@
         in pd { library = Just lib' }
     Nothing ->
         error "Expected a library, but none found"
-
-build_primitive_sources :: Hook a -> Hook a
-build_primitive_sources f pd lbi uhs x
- = do when (compilerFlavor (compiler lbi) == GHC) $ do
-          let genprimopcode = joinPath ["..", "..", "utils",
-                                        "genprimopcode", "genprimopcode"]
-              primops = joinPath ["..", "..", "compiler", "prelude",
-                                  "primops.txt"]
-              primhs = joinPath ["GHC", "Prim.hs"]
-              primopwrappers = joinPath ["GHC", "PrimopWrappers.hs"]
-              primhs_tmp = addExtension primhs "tmp"
-              primopwrappers_tmp = addExtension primopwrappers "tmp"
-          maybeExit $ system (genprimopcode ++ " --make-haskell-source < "
-                           ++ primops ++ " > " ++ primhs_tmp)
-          maybeUpdateFile primhs_tmp primhs
-          maybeExit $ system (genprimopcode ++ " --make-haskell-wrappers < "
-                           ++ primops ++ " > " ++ primopwrappers_tmp)
-          maybeUpdateFile primopwrappers_tmp primopwrappers
-      f pd lbi uhs x
-
--- Replace a file only if the new version is different from the old.
--- This prevents make from doing unnecessary work after we run 'setup makefile'
-maybeUpdateFile :: FilePath -> FilePath -> IO ()
-maybeUpdateFile source target = do
-  r <- rawSystem "cmp" ["-s" {-quiet-}, source, target]
-  case r of
-    ExitSuccess   -> removeFile source
-    ExitFailure _ -> do exists <- doesFileExist target
-                        when exists $ removeFile target
-                        renameFile source target
-
diff -ruN -x '*.rej' -x '*.orig' old/libraries/ghc-prim/ghc-prim.cabal new/libraries/ghc-prim/ghc-prim.cabal
--- old/libraries/ghc-prim/ghc-prim.cabal	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/ghc-prim/ghc-prim.cabal	2019-05-13 13:38:44.000000000 +1200
@@ -59,6 +59,8 @@
         GHC.Tuple
         GHC.Types
 
+        Asterius.Magic
+
     virtual-modules:
         GHC.Prim
 
diff -ruN -x '*.rej' -x '*.orig' old/libraries/ghci/ghci.cabal new/libraries/ghci/ghci.cabal
--- old/libraries/ghci/ghci.cabal	1970-01-01 12:00:00.000000000 +1200
+++ new/libraries/ghci/ghci.cabal	2019-05-21 15:33:18.000000000 +1200
@@ -0,0 +1,88 @@
+-- WARNING: ghci.cabal is automatically generated from ghci.cabal.in by
+-- ../../configure.  Make sure you are editing ghci.cabal.in, not ghci.cabal.
+
+name:           ghci
+version:        8.9
+license:        BSD3
+license-file:   LICENSE
+category:       GHC
+maintainer:     ghc-devs@haskell.org
+bug-reports:    https://gitlab.haskell.org/ghc/ghc/issues/new
+synopsis:       The library supporting GHC's interactive interpreter
+description:
+            This library offers interfaces which mediate interactions between the
+            @ghci@ interactive shell and @iserv@, GHC's out-of-process interpreter
+            backend.
+cabal-version:  >=1.10
+build-type:     Simple
+extra-source-files: changelog.md
+
+Flag ghci
+    Description: Build GHCi support.
+    Default: False
+    Manual: True
+
+source-repository head
+    type:     git
+    location: http://git.haskell.org/ghc.git
+    subdir:   libraries/ghci
+
+library
+    default-language: Haskell2010
+    default-extensions: NoImplicitPrelude
+    other-extensions:
+        BangPatterns
+        CPP
+        DeriveGeneric
+        ExistentialQuantification
+        FlexibleInstances
+        GADTs
+        GeneralizedNewtypeDeriving
+        InstanceSigs
+        MagicHash
+        MultiParamTypeClasses
+        RecordWildCards
+        ScopedTypeVariables
+        StandaloneDeriving
+        TupleSections
+        UnboxedTuples
+
+    if flag(ghci)
+        CPP-Options: -DGHCI
+        exposed-modules:
+            GHCi.Run
+            GHCi.CreateBCO
+            GHCi.ObjLink
+            GHCi.Signals
+            GHCi.TH
+
+    exposed-modules:
+        GHCi.BreakArray
+        GHCi.BinaryArray
+        GHCi.Message
+        GHCi.ResolvedBCO
+        GHCi.RemoteTypes
+        GHCi.FFI
+        GHCi.InfoTable
+        GHCi.StaticPtrTable
+        GHCi.TH.Binary
+        SizedSeq
+
+    Build-Depends:
+        array            == 0.5.*,
+        base             >= 4.8 && < 4.14,
+        binary           == 0.8.*,
+        bytestring       == 0.10.*,
+        containers       >= 0.5 && < 0.7,
+        deepseq          == 1.4.*,
+        filepath         == 1.4.*,
+        ghc-boot         == 8.6.4,
+        ghc-boot-th      == 8.6.4,
+        ghc-heap         == 8.6.4,
+        template-haskell == 2.14.*,
+        transformers     == 0.5.*
+
+    if !os(windows)
+        Build-Depends: unix >= 2.7 && < 2.9
+
+    include-dirs: ../includes
diff -ruN -x '*.rej' -x '*.orig' old/libraries/integer-gmp/integer-gmp.cabal new/libraries/integer-gmp/integer-gmp.cabal
--- old/libraries/integer-gmp/integer-gmp.cabal	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/integer-gmp/integer-gmp.cabal	2019-05-20 20:51:17.000000000 +1200
@@ -60,7 +60,10 @@
     UnliftedFFITypes
   build-depends:       ghc-prim ^>= 0.5.1.0
   hs-source-dirs:      src/
-  ghc-options: -this-unit-id integer-gmp -Wall
+  -- We need to set the unit ID to integer-wired-in
+  -- (without a version number) as it's magic.
+  -- See Note [The integer library] in PrelNames
+  ghc-options: -this-unit-id integer-wired-in -Wall
   cc-options: -std=c99 -Wall
 
   include-dirs: include
diff -ruN -x '*.rej' -x '*.orig' old/libraries/integer-simple/GHC/Integer/Logarithms/Internals.hs new/libraries/integer-simple/GHC/Integer/Logarithms/Internals.hs
--- old/libraries/integer-simple/GHC/Integer/Logarithms/Internals.hs	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/integer-simple/GHC/Integer/Logarithms/Internals.hs	2019-05-20 21:12:35.000000000 +1200
@@ -1,4 +1,5 @@
 {-# LANGUAGE CPP, MagicHash, UnboxedTuples, NoImplicitPrelude #-}
+{-# LANGUAGE UnliftedFFITypes #-}
 {-# OPTIONS_HADDOCK hide #-}
 
 #include "MachDeps.h"
@@ -17,6 +18,10 @@
     , roundingMode#
     ) where
 
+#if defined(ASTERIUS)
+import Asterius.Magic
+#endif
+
 import GHC.Prim
 import GHC.Integer.Type
 import GHC.Types
@@ -92,6 +97,9 @@
 -- otherwise return -1# arbitrarily
 -- Going up in word-sized steps should not be too bad.
 integerLog2# :: Integer -> Int#
+#if defined(ASTERIUS)
+integerLog2# (Integer i) = js_integerLog2 i
+#else
 integerLog2# (Positive digits) = step 0# digits
   where
     step acc (Some dig None) = acc +# wordLog2# dig
@@ -99,9 +107,13 @@
         step (acc +# WORD_SIZE_IN_BITS#) digs
     step acc None = acc     -- should be impossible, throw error?
 integerLog2# _ = negateInt# 1#
+#endif
 
 -- Again, integer should be strictly positive
 integerLog2IsPowerOf2# :: Integer -> (# Int#, Int# #)
+#if defined(ASTERIUS)
+integerLog2IsPowerOf2# (Integer i) = (# js_integerLog2 i, js_integerIsPowerOf2 i #)
+#else
 integerLog2IsPowerOf2# (Positive digits) = couldBe 0# digits
   where
     couldBe acc (Some dig None) =
@@ -117,6 +129,7 @@
         noPower (acc +# WORD_SIZE_IN_BITS#) digs
     noPower acc None = (# acc, 1# #) -- should be impossible, error?
 integerLog2IsPowerOf2# _ = (# negateInt# 1#, 1# #)
+#endif
 
 -- Assumption: Integer and Int# are strictly positive, Int# is less
 -- than logBase 2 of Integer, otherwise havoc ensues.
@@ -164,3 +177,11 @@
                               (# _, ba #) -> ba
     in case mkArr realWorld# of
         b -> BA b
+
+#if defined(ASTERIUS)
+
+foreign import javascript "__asterius_jsffi.Integer.integerLogBase(${1}, 4)" js_integerLog2 :: Int# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.integerIsPowerOf2(${1})" js_integerIsPowerOf2 :: Int# -> Int#
+
+#endif
diff -ruN -x '*.rej' -x '*.orig' old/libraries/integer-simple/GHC/Integer/Logarithms.hs new/libraries/integer-simple/GHC/Integer/Logarithms.hs
--- old/libraries/integer-simple/GHC/Integer/Logarithms.hs	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/integer-simple/GHC/Integer/Logarithms.hs	2019-05-13 13:38:44.000000000 +1200
@@ -1,4 +1,7 @@
+{-# LANGUAGE CPP #-}
 {-# LANGUAGE MagicHash, UnboxedTuples, NoImplicitPrelude #-}
+{-# LANGUAGE UnliftedFFITypes #-}
+
 module GHC.Integer.Logarithms
     ( integerLogBase#
     , integerLog2#
@@ -8,6 +11,12 @@
 import GHC.Prim
 import GHC.Integer
 import qualified GHC.Integer.Logarithms.Internals as I
+import GHC.Types
+
+#if defined(ASTERIUS)
+import Asterius.Magic
+import GHC.Integer.Type (Integer(..))
+#endif
 
 -- | Calculate the integer logarithm for an arbitrary base.
 --   The base must be greater than 1, the second argument, the number
@@ -18,6 +27,9 @@
 --
 -- for @base > 1@ and @m > 0@.
 integerLogBase# :: Integer -> Integer -> Int#
+#if defined(ASTERIUS)
+integerLogBase# (Integer b) (Integer m) = js_integerLogBase m b
+#else
 integerLogBase# b m = case step b of
                         (# _, e #) -> e
   where
@@ -29,6 +41,7 @@
                  if q `ltInteger` pw
                    then (# q, 2# *# e #)
                    else (# q `quotInteger` pw, 2# *# e +# 1# #)
+#endif
 
 -- | Calculate the integer base 2 logarithm of an 'Integer'.
 --   The calculation is more efficient than for the general case,
@@ -41,3 +54,9 @@
 -- | This function calculates the integer base 2 logarithm of a 'Word#'.
 wordLog2# :: Word# -> Int#
 wordLog2# = I.wordLog2#
+
+#if defined(ASTERIUS)
+
+foreign import javascript "__asterius_jsffi.Integer.integerLogBase(${1}, ${2})" js_integerLogBase :: Int# -> Int# -> Int#
+
+#endif
diff -ruN -x '*.rej' -x '*.orig' old/libraries/integer-simple/GHC/Integer/Type.hs new/libraries/integer-simple/GHC/Integer/Type.hs
--- old/libraries/integer-simple/GHC/Integer/Type.hs	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/integer-simple/GHC/Integer/Type.hs	2019-05-20 21:32:45.000000000 +1200
@@ -26,6 +26,270 @@
 
 module GHC.Integer.Type where
 
+#if defined(ASTERIUS)
+
+import Asterius.Magic
+import GHC.Classes
+import GHC.Magic
+import GHC.Prim
+import GHC.Types
+
+data Integer = Integer Int#
+
+mkInteger :: Bool -> [Int] -> Integer
+mkInteger nonNegative is =
+  runRW#
+    (\s0 ->
+       case unIO (js_newInteger nonNegative) s0 of
+         (# s1, i0 #) ->
+           let w [] sx = (# sx, () #)
+               w (x:xs) sx =
+                 case unIO (js_prependInteger i0 x) sx of
+                   (# sy, _ #) -> w xs sy
+            in case w is s1 of
+                 (# s2, _ #) ->
+                   case unIO (js_freezeInteger i0) s2 of
+                     (# _, I# r #) -> Integer r)
+
+smallInteger :: Int# -> Integer
+smallInteger i = Integer (js_smallInteger i)
+
+wordToInteger :: Word# -> Integer
+wordToInteger w = Integer (js_wordToInteger w)
+
+integerToWord :: Integer -> Word#
+integerToWord (Integer i) = js_integerToWord i
+
+integerToInt :: Integer -> Int#
+integerToInt (Integer i) = js_integerToInt i
+
+plusInteger :: Integer -> Integer -> Integer
+plusInteger (Integer i0) (Integer i1) = Integer (js_plusInteger i0 i1)
+
+minusInteger :: Integer -> Integer -> Integer
+minusInteger (Integer i0) (Integer i1) = Integer (js_minusInteger i0 i1)
+
+timesInteger :: Integer -> Integer -> Integer
+timesInteger (Integer i0) (Integer i1) = Integer (js_timesInteger i0 i1)
+
+negateInteger :: Integer -> Integer
+negateInteger (Integer i) = Integer (js_negateInteger i)
+
+eqInteger :: Integer -> Integer -> Bool
+eqInteger (Integer i0) (Integer i1) = js_eqInteger i0 i1
+
+neqInteger :: Integer -> Integer -> Bool
+neqInteger (Integer i0) (Integer i1) = js_neqInteger i0 i1
+
+absInteger :: Integer -> Integer
+absInteger (Integer i) = Integer (js_absInteger i)
+
+signumInteger :: Integer -> Integer
+signumInteger (Integer i) = Integer (js_signumInteger i)
+
+leInteger :: Integer -> Integer -> Bool
+leInteger (Integer i0) (Integer i1) = js_leInteger i0 i1
+
+gtInteger :: Integer -> Integer -> Bool
+gtInteger (Integer i0) (Integer i1) = js_gtInteger i0 i1
+
+ltInteger :: Integer -> Integer -> Bool
+ltInteger (Integer i0) (Integer i1) = js_ltInteger i0 i1
+
+geInteger :: Integer -> Integer -> Bool
+geInteger (Integer i0) (Integer i1) = js_geInteger i0 i1
+
+compareInteger :: Integer -> Integer -> Ordering
+compareInteger (Integer i0) (Integer i1) =
+  if js_eqInteger i0 i1
+    then EQ
+    else if js_leInteger i0 i1
+           then LT
+           else GT
+
+eqInteger# :: Integer -> Integer -> Int#
+eqInteger# (Integer i0) (Integer i1) = unBool (js_eqInteger i0 i1)
+
+neqInteger# :: Integer -> Integer -> Int#
+neqInteger# (Integer i0) (Integer i1) = unBool (js_neqInteger i0 i1)
+
+leInteger# :: Integer -> Integer -> Int#
+leInteger# (Integer i0) (Integer i1) = unBool (js_leInteger i0 i1)
+
+gtInteger# :: Integer -> Integer -> Int#
+gtInteger# (Integer i0) (Integer i1) = unBool (js_gtInteger i0 i1)
+
+ltInteger# :: Integer -> Integer -> Int#
+ltInteger# (Integer i0) (Integer i1) = unBool (js_ltInteger i0 i1)
+
+geInteger# :: Integer -> Integer -> Int#
+geInteger# (Integer i0) (Integer i1) = unBool (js_geInteger i0 i1)
+
+divModInteger :: Integer -> Integer -> (# Integer, Integer #)
+n `divModInteger` d =
+    case n `quotRemInteger` d of
+        (# q, r #) ->
+            if signumInteger r `eqInteger`
+               negateInteger (signumInteger d)
+            then (# q `minusInteger` oneInteger, r `plusInteger` d #)
+            else (# q, r #)
+
+divInteger :: Integer -> Integer -> Integer
+n `divInteger` d = quotient
+    where (# quotient, _ #) = n `divModInteger` d
+
+modInteger :: Integer -> Integer -> Integer
+n `modInteger` d = modulus
+    where (# _, modulus #) = n `divModInteger` d
+
+quotRemInteger :: Integer -> Integer -> (# Integer, Integer #)
+quotRemInteger (Integer i0) (Integer i1) =
+  (# Integer (js_quotInteger i0 i1), Integer (js_remInteger i0 i1) #)
+
+quotInteger :: Integer -> Integer -> Integer
+quotInteger (Integer i0) (Integer i1) = Integer (js_quotInteger i0 i1)
+
+remInteger :: Integer -> Integer -> Integer
+remInteger (Integer i0) (Integer i1) = Integer (js_remInteger i0 i1)
+
+encodeFloatInteger :: Integer -> Int# -> Float#
+encodeFloatInteger (Integer m) n = js_encodeFloatInteger m n
+
+decodeFloatInteger :: Float# -> (# Integer, Int# #)
+decodeFloatInteger f =
+  (# Integer (js_decodeFloatInteger_m f), js_decodeFloatInteger_n f #)
+
+floatFromInteger :: Integer -> Float#
+floatFromInteger (Integer i) = js_floatFromInteger i
+
+encodeDoubleInteger :: Integer -> Int# -> Double#
+encodeDoubleInteger (Integer m) n = js_encodeDoubleInteger m n
+
+decodeDoubleInteger :: Double# -> (# Integer, Int# #)
+decodeDoubleInteger d = (# Integer (js_decodeDoubleInteger_m d), js_decodeDoubleInteger_n d #)
+
+doubleFromInteger :: Integer -> Double#
+doubleFromInteger (Integer i) = js_doubleFromInteger i
+
+andInteger :: Integer -> Integer -> Integer
+andInteger (Integer i0) (Integer i1) = Integer (js_andInteger i0 i1)
+
+orInteger :: Integer -> Integer -> Integer
+orInteger (Integer i0) (Integer i1) = Integer (js_orInteger i0 i1)
+
+xorInteger :: Integer -> Integer -> Integer
+xorInteger (Integer i0) (Integer i1) = Integer (js_xorInteger i0 i1)
+
+complementInteger :: Integer -> Integer
+complementInteger (Integer i) = Integer (js_complementInteger i)
+
+shiftLInteger :: Integer -> Int# -> Integer
+shiftLInteger (Integer i0) i1 = Integer (js_shiftLInteger i0 i1)
+
+shiftRInteger :: Integer -> Int# -> Integer
+shiftRInteger (Integer i0) i1 = Integer (js_shiftRInteger i0 i1)
+
+testBitInteger :: Integer -> Int# -> Bool
+testBitInteger (Integer i0) i1 = js_testBitInteger i0 i1
+
+hashInteger :: Integer -> Int#
+hashInteger (Integer i) = js_hashInteger i
+
+oneInteger :: Integer
+oneInteger = smallInteger 1#
+
+powInteger :: Integer -> Integer -> Integer
+powInteger (Integer i0) (Integer i1) = Integer (js_powInteger i0 i1)
+
+instance Eq Integer where
+  (==) = eqInteger
+  (/=) = neqInteger
+
+instance Ord Integer where
+  (<=) = leInteger
+  (>) = gtInteger
+  (<) = ltInteger
+  (>=) = geInteger
+  compare = compareInteger
+
+foreign import javascript "__asterius_jsffi.Integer.newInteger(${1})" js_newInteger :: Bool -> IO Int
+
+foreign import javascript "__asterius_jsffi.Integer.prependInteger(${1},${2})" js_prependInteger :: Int -> Int -> IO ()
+
+foreign import javascript "__asterius_jsffi.Integer.freezeInteger(${1})" js_freezeInteger :: Int -> IO Int
+
+foreign import javascript "__asterius_jsffi.Integer.smallInteger(${1})" js_smallInteger :: Int# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.smallInteger(${1})" js_wordToInteger :: Word# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.integerToWord(${1})" js_integerToWord :: Int# -> Word#
+
+foreign import javascript "__asterius_jsffi.Integer.integerToInt(${1})" js_integerToInt :: Int# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.plusInteger(${1},${2})" js_plusInteger :: Int# -> Int# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.minusInteger(${1},${2})" js_minusInteger :: Int# -> Int# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.timesInteger(${1},${2})" js_timesInteger :: Int# -> Int# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.negateInteger(${1})" js_negateInteger :: Int# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.eqInteger(${1},${2})" js_eqInteger :: Int# -> Int# -> Bool
+
+foreign import javascript "__asterius_jsffi.Integer.neqInteger(${1},${2})" js_neqInteger :: Int# -> Int# -> Bool
+
+foreign import javascript "__asterius_jsffi.Integer.absInteger(${1})" js_absInteger :: Int# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.signumInteger(${1})" js_signumInteger :: Int# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.leInteger(${1},${2})" js_leInteger :: Int# -> Int# -> Bool
+
+foreign import javascript "__asterius_jsffi.Integer.gtInteger(${1},${2})" js_gtInteger :: Int# -> Int# -> Bool
+
+foreign import javascript "__asterius_jsffi.Integer.ltInteger(${1},${2})" js_ltInteger :: Int# -> Int# -> Bool
+
+foreign import javascript "__asterius_jsffi.Integer.geInteger(${1},${2})" js_geInteger :: Int# -> Int# -> Bool
+
+foreign import javascript "__asterius_jsffi.Integer.quotInteger(${1},${2})" js_quotInteger :: Int# -> Int# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.remInteger(${1},${2})" js_remInteger :: Int# -> Int# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.encodeDoubleInteger(${1},${2})" js_encodeFloatInteger :: Int# -> Int# -> Float#
+
+foreign import javascript "__asterius_jsffi.Integer.encode(__asterius_jsffi.Integer.decodeDoubleInteger(${1})[0])" js_decodeFloatInteger_m :: Float# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.decodeDoubleInteger(${1})[1]" js_decodeFloatInteger_n :: Float# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.doubleFromInteger(${1})" js_floatFromInteger :: Int# -> Float#
+
+foreign import javascript "__asterius_jsffi.Integer.encodeDoubleInteger(${1},${2})" js_encodeDoubleInteger :: Int# -> Int# -> Double#
+
+foreign import javascript "__asterius_jsffi.Integer.encode(__asterius_jsffi.Integer.decodeDoubleInteger(${1})[0])" js_decodeDoubleInteger_m :: Double# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.decodeDoubleInteger(${1})[1]" js_decodeDoubleInteger_n :: Double# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.doubleFromInteger(${1})" js_doubleFromInteger :: Int# -> Double#
+
+foreign import javascript "__asterius_jsffi.Integer.andInteger(${1},${2})" js_andInteger :: Int# -> Int# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.orInteger(${1},${2})" js_orInteger :: Int# -> Int# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.xorInteger(${1},${2})" js_xorInteger :: Int# -> Int# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.complementInteger(${1})" js_complementInteger :: Int# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.shiftLInteger(${1},${2})" js_shiftLInteger :: Int# -> Int# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.shiftRInteger(${1},${2})" js_shiftRInteger :: Int# -> Int# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.testBitInteger(${1},${2})" js_testBitInteger :: Int# -> Int# -> Bool
+
+foreign import javascript "__asterius_jsffi.Integer.hashInteger(${1})" js_hashInteger :: Int# -> Int#
+
+foreign import javascript "__asterius_jsffi.Integer.powInteger(${1},${2})" js_powInteger :: Int# -> Int# -> Int#
+
+#else
+
 import GHC.Prim
 import GHC.Classes
 import GHC.Types
@@ -889,3 +1153,5 @@
     orDigits (Some w1 ds1) (Some w2 ds2) = Some ... ...
 -}
 
+#endif
+
diff -ruN -x '*.rej' -x '*.orig' old/libraries/integer-simple/integer-simple.cabal new/libraries/integer-simple/integer-simple.cabal
--- old/libraries/integer-simple/integer-simple.cabal	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/integer-simple/integer-simple.cabal	2019-05-20 20:51:38.000000000 +1200
@@ -26,6 +26,6 @@
     other-modules: GHC.Integer.Type
     default-extensions: CPP, MagicHash, BangPatterns, UnboxedTuples,
                 UnliftedFFITypes, NoImplicitPrelude
-    -- We need to set the unit ID to integer-simple
+    -- We need to set the unit ID to integer-wired-in
     -- (without a version number) as it's magic.
-    ghc-options: -this-unit-id integer-simple -Wall
+    ghc-options: -this-unit-id integer-wired-in -Wall
diff -ruN -x '*.rej' -x '*.orig' old/libraries/rts/PrimOps.cmm new/libraries/rts/PrimOps.cmm
--- old/libraries/rts/PrimOps.cmm	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/rts/PrimOps.cmm	2019-05-13 13:38:52.000000000 +1200
@@ -875,7 +875,7 @@
     gcptr threadid;
 
     ("ptr" threadid) = ccall createIOThread( MyCapability() "ptr",
-                                  RtsFlags_GcFlags_initialStkSize(RtsFlags),
+                                  TO_W_(RtsFlags_GcFlags_initialStkSize(RtsFlags)),
                                   closure "ptr");
 
     /* start blocked if the current thread is blocked */
@@ -900,7 +900,7 @@
 
     ("ptr" threadid) = ccall createIOThread(
         MyCapability() "ptr",
-        RtsFlags_GcFlags_initialStkSize(RtsFlags),
+        TO_W_(RtsFlags_GcFlags_initialStkSize(RtsFlags)),
         closure "ptr");
 
     /* start blocked if the current thread is blocked */
@@ -1888,7 +1888,8 @@
 stg_deRefStablePtrzh ( P_ sp )
 {
     W_ r;
-    r = spEntry_addr(W_[stable_ptr_table] + sp*SIZEOF_spEntry);
+    
+    ("ptr" r) = ccall deRefStablePtr(sp "ptr");
     return (r);
 }
 
diff -ruN -x '*.rej' -x '*.orig' old/libraries/rts/rts.conf new/libraries/rts/rts.conf
--- old/libraries/rts/rts.conf	1970-01-01 12:00:00.000000000 +1200
+++ new/libraries/rts/rts.conf	2019-05-13 13:38:52.000000000 +1200
@@ -0,0 +1,10 @@
+name: rts
+version: 1.0
+id: rts
+key: rts
+license: BSD-3-Clause
+maintainer: glasgow-haskell-users@haskell.org
+exposed: True
+library-dirs: $topdir/rts
+hs-libraries: HSrts
+include-dirs: $topdir/include
diff -ruN -x '*.rej' -x '*.orig' old/libraries/unix/System/Posix/IO/Common.hsc new/libraries/unix/System/Posix/IO/Common.hsc
--- old/libraries/unix/System/Posix/IO/Common.hsc	1970-01-01 12:00:01.000000000 +1200
+++ new/libraries/unix/System/Posix/IO/Common.hsc	2019-05-13 13:38:53.000000000 +1200
@@ -208,6 +208,9 @@
 fdToHandle :: Fd -> IO Handle
 fdToHandle fd = FD.fdToHandle (fromIntegral fd)
 
+#if defined(ASTERIUS)
+handleToFd (Handle h) = pure (Fd (fromIntegral h))
+#else
 handleToFd h@(FileHandle _ m) = do
   withHandle' "handleToFd" h m $ handleToFd' h
 handleToFd h@(DuplexHandle _ r w) = do
@@ -216,7 +219,9 @@
   -- for a DuplexHandle, make sure we mark both sides as closed,
   -- otherwise a finalizer will come along later and close the other
   -- side. (#3914)
+#endif
 
+#if !defined(ASTERIUS)
 handleToFd' :: Handle -> Handle__ -> IO (Handle__, Fd)
 handleToFd' h h_@Handle__{haType=_,..} = do
   case cast haDevice of
@@ -230,7 +235,7 @@
      flushWriteBuffer h_
      FD.release fd
      return (Handle__{haType=ClosedHandle,..}, Fd (FD.fdFD fd))
-
+#endif
 
 -- -----------------------------------------------------------------------------
 -- Fd options
